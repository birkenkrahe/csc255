#+TITLE:Agenda - Computer Architecture
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:CSC 255 Agenda Fall 2025
#+STARTUP: overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:R :session *R* :results output :exports both :noweb yes
#+PROPERTY: header-args:python :session *Python* :results output :exports both :noweb yes
#+PROPERTY: header-args:C :main yes :includes <stdio.h> :results output :exports both :noweb yes
#+PROPERTY: header-args:C++ :main yes :includes <iostream> :results output :exports both :noweb yes
* Week 0: Overview

- Tools used and plans made
- Motivation to enrol in the course

* Week 1: Overview: Why computer architecture, LogiSim installation

- [X] Reviews
- [X] Installation: LogiSim
- [X] Nand2Tetris projects
- [ ] *Research mixer on Tuesday, September 30 @Lyon - tinyurl.com/res-mix*
- [ ] Why Computer architecture?

** DONE Review Week 0

1. Which tools are we going to use in this course?
   #+begin_quote
   - Hardware Description Language (HDL)
   - LogiSim (digital circuit simulator)
   - GDB (GNU DeBugger) and GCC (GNU C Compiler)
   #+end_quote
2. What stands between source code and machine code?
   #+begin_quote
   Source code (in any high level language) is compiled into
   human-readable Assembly code and then linked to not human-readable
   object code for execution. (Though some compilers generate object
   code directly - Assembly is not always exposed.)
   #+end_quote
3. What is specialy about this intermediate step?
   #+begin_quote
   What's special about Assembly is that it depends on the CPU. Each
   machine has an instruction set architecture (ISA) that is
   specific. The assembly file and the object code of one CPU will not
   run on another.
   #+end_quote
4. Which programming languages are portable?
   #+begin_quote
   No language is "portable". Their implementation makes them
   portable:

   - C and C++: The source code is portable, but the compiled binary
     is not. You need a compiler for each target architecture.
   - Python and JavaScript: Interpreted (or Just-In-Time compiled) -
     source runs cross-platform if the interpreter is available.
   - Java: uses intermediate bytecode that runs on a Java Virtual
     Machine (JVM), which is ported to many hardware platforms.
   #+end_quote
5. What is the Gestalt principle, and how does it apply to computer
   architecture?
   #+begin_quote
   The Gestalt (German for 'shape') principle comes from psychology:
   "The whole is greater than the sum of its parts." It means that we
   perceive systems as unified structures, not just isolated
   components.

   In computer architecture, the Gestalt idea applies because a
   computer is not just CPU + memory + I/O in isolation. The
   organization and interaction of these components give rise to
   capabilities (like parallelism, pipelining, or memory hierarchies)
   that cannot be understood by looking at the parts alone.
   #+end_quote

** DONE Syllabus

- New attendance policy and app (QR code)
- Updated AI guidelines
- Project-centered grading
- Textbooks (optional): CS:APP / Nand2Tetris

** DONE Schedule

| Week(s) | Topic                           | Notes                             |
|---------+---------------------------------+-----------------------------------|
| 1       | Intro to Systems & Architecture | Abstractions, tools, setup        |
| 2–3     | Project 1: Boolean Logic        | HDL, logic gates, test scripts    |
| 4–5     | Project 2: Combinational Chips  | Adders, ALU parts, multiplexers   |
| 6–7     | Project 3: Sequential Chips     | Flip-flops, RAM, memory hierarchy |
| 8–9     | Project 4: Machine Language     | Hack code, write simple programs  |
| 10–11   | Project 5: Hack CPU             | Build CPU, connect components     |
| 12–13   | Project 6: Assembler            | Write assembler, resolve symbols  |
| 14      | Integration & Demo Prep         | I/O mapping, final integration    |
| 15      | Hack Computer Demo              | Demo: HDL → CPU → Assembler stack |

** DONE Projects

*** The Idea of Nand2Tetris
#+attr_html: :width 400px :float nil:
[[../img/michelangelo.png]]

*** The course projects (Hack hardware)
#+attr_html: :width 600px :float nil:
#+Caption: Nand2Tetris projects we may be able to complete in CSC 255.
[[../img/projects.png]]

*** Other projects (Hack software)
#+attr_html: :width 600px :float nil:
#+Caption: Nand2Tetris projects that we will not cover in CSC 255.
[[../img/projectsOS.png]]

** DONE Install LogiSim

- [[https://cdn.hackaday.io/files/1814287762215552/logisim_tutorial.pdf][The Guide to Being a LogiSim User (tutorial)]]

- Go to [[https://github.com/logisim-evolution/][github.com/logisim-evolution/]]

- Navigate to the [[https://github.com/logisim-evolution/logisim-evolution/releases][releases repo]]

- Download what you need for Windows (msi), MacOS (dmg), or Linux
  (rpm)

- You must have Java installed (in a terminal, run =java --version=)

- On Windows, double-click the .msi file and change the location to
  your local disk (=C:/Users/yourname=). Or download and run the .jar
  file.

- On MacOS, double-click the .dmg file then drag the Logisim-Evolution
  icon into the Applications folder.

- On Linux, if you're on Debian, download the .deb file and run
  #+begin_example
  sudo dpkg -i logisim-evolution-3.9.0_[cpu].deb
  #+end_example

- Check that your program exists and open it to create your first
  diagram.


** DONE Research mixer - why you should do this
#+attr_html: :width 400px :float nil:
[[../img/research_mixer.png]]

- Doing research is a great excuse to build a relationship with a
  business: People love to help, especially techies!

- This is practical networking that can help you get an internship or
  a job: You can put it on your resume, too!

- Through research, you learn to update your knowledge, and you may
  find out about interesting applications that define your career!

- Science is at crossroads for multiple reasons: It's too bloated,
  it's too expensive, it's getting too difficult, and there's AI.

** DONE Brilliant course
#+attr_html: :width 400px :float nil:
[[../img/brilliant2.png]]

- Start the free [[https://brilliant.org/courses/digital-circuits/]["digital circuits" course on brilliant.org]] to
  revitalize your digital logics knowledge and to get a view of all
  the different aspect of the CPU.

- I am on day 56 currently, starting with Nand gates - which we're
  assuming as prerequisite knowledge here.

- Includes 3 daily practice questions. You can finish in 1 month.

** DONE Review (Monday)

1. What is a compiler flag - can you give an example?
   #+begin_src bash :results output :exports both
     cd ../src
     echo -e "#include <iostream>\nint main(){\
     std::cout<<\"Hello, world!\";return 0;}" > hello.cpp
     cat hello.cpp
     g++ hello.cpp -o hello
     ./hello
   #+end_src

   #+RESULTS:
   : #include <iostream>
   : int main(){std::cout<<"Hello, world!";return 0;}
   : Hello, world!

2. What does a digital NOT circuit consist of?
   #+begin_quote
   1) An input pin (Voltage ON/OFF)
   2) An output pin (Voltage OFF/ON)
   3) A Not gate

   [[../img/Not.png]]
   #+end_quote

3. What kind of application is LogiSim Evolution?
   #+begin_quote
   - Free open source software (FOSS)
   - Java application (.jar)
   - Digital Circuit simulation software
   #+end_quote

4. Discuss this with your neighbor and come to a presentable
   conclusion: Do logical statements, truth tables, and circuit
   diagrams express *exactly* the same information? For example,
   consider NOT:

   - Logical statement: =NOT(A)= or algebraically y = \not x

   - Truth table:
     | A | NOT(A) |
     |---+--------|
     | 0 |      1 |
     | 1 |      0 |

   - Digital circuit diagram:
     #+attr_html: :width 400px :float nil:
     [[../img/Not.png]]

   - Answer:
     #+begin_quote
     Yes: Logical statement, truth table and circuit diagram all show a
     representation of the same Boolean function f:x^{1}{0,1}->{0,1}.

     And No: The level and kind of of abstraction differs: Logic
     notation show algebraic manipulation; truth tables show the state
     space; and circuits show physical realization (voltage, wires,
     gates).

     If the level and kind of abstraction differs, then different
     details have been eliminated and the result has a different
     information content.
     #+end_quote

5. Which of these representations is your personal favorite? Why do
   you think that is?
   #+begin_quote
   - Some properties like identities and laws (De Morgan,
     distribution) are only visible algebraically. Expressions can
     be transformed using these laws. More information for the
     *mathematician* and fan of symbolic manipulation.
   - The truth table completely describes the function for a fixed
     number of inputs, listing all outputs. Its abstraction is close
     to the capabilities of a brute force machine (loop over all
     values). More information for the *computer scientist*.
   - Some properties (timing, propagation delay, power use) are only
     visible in the circuit-level representation: More information
     for the *engineer* and spatial thinker.
   #+end_quote

** IN PROGRESS Overview

- [X] Some questions to begin with
- [ ] Why Computer Architecture
- [ ] Arithmetic
- [ ] Assembly
- [ ] Memory
- [ ] Optimization
- [ ] Networks

** Review (Wednesday)

1. Can you write and run a C++ "hello world" pgm on the command-line?
   #+begin_src bash :results output :exports both
     # write text to stdout and redirect it into a C++ file
     echo -e "#include <iostream>\nint main() {\n  std::cout<<\"hello world\";\n}" > hello.cpp
     cat hello.cpp
     # compile and run C++ file
     g++ hello.cpp -o hello
     ./hello
   #+end_src

   #+RESULTS:
   : #include <iostream>
   : int main() {
   :   std::cout<<"hello world";
   : }
   : hello world

2. What are the three parts of a computer *system*?
   #+begin_quote
   1) Hardware (CPU),
   2) system software (OS),
   3) application programs (compiler)
   #+end_quote

3. What are the parts of a computer architecture?
   #+begin_quote
   1) ISA (instruction set architecture/CPU),
   2) microarchitecture (data flow/ALU/cache),
   3) system organization (memory bus).
   #+end_quote

** NEXT Assignments for next week

- [X] [[https://lyon.instructure.com/courses/3673/assignments/50009/edit?quiz_lti][Test 1 in Canvas]] (open book) - by September 7 (Friday)

  This first test covers the material seen and taught until Friday,
  August 29. Check the reviews in the agenda.org file to prepare.


- [X] Watch "[[https://youtu.be/dX9CGRZwD-w?si=KDARgJLQz7Bd3IEu][How are transistors manufactured?]]" (2024) - 30 min

  This video explains how modern microchips, containing billions of
  nanoscopic (distances of 1 billionth of a meter) transistors, are
  manufactured in semiconductor fabrication plants. Though we're not
  primarily interested in manufacturing chips, this is both
  interesting and relevant to appreciate the complexity of computer
  systems. [Review & Test].

- [X] Watch "[[https://youtu.be/sTu3LwpF6XI?si=k1DRLefz6b9OSKTu][Making logic gates from transistors]]" (2015) - 15 min

  The video introduces transistors and shows how they can be used as
  building blocks for digital logic. Though this concerns physics and
  electrical engineering, seeing how logic gates are implemented via
  transistors and circuits will add to your understanding of the
  microarchitecture of computer systems. [Review & Test].

- [X] [[https://lyon.instructure.com/courses/3673/assignments/50014][Install LogiSim on your home desktop or laptop:]]

  1) Install LogiSim on your own computer.
  2) Build a NOT gate as seen in class.
  3) Take a screenshot and upload it to Canvas.

* Week 2: Microchips, logic gates, (Sep 5)

- [X] Popquiz! What do you remember from the videos? Take the
  solutions home, grade yourself, and return the test next week.

- [X] Finish: Assembly and the machine.

** Review: How are Microchips made? ([[https://youtu.be/dX9CGRZwD-w?si=KDARgJLQz7Bd3IEu][Branch Education, YouTube 2024]])

1. What is the approximate number of steps required to manufacture a
   modern CPU chip?
   #+begin_quote
   Around 940 steps, taking about 3 months.
   #+end_quote
2. What type of transistor structure is commonly used in today’s CPUs,
   and how small are they?
   #+begin_quote
   FinFET (Fin Field-Effect) transistors, with dimensions on the order
   of tens of nanometers (e.g., 36×6×52 nm). A 3D transistor rather
   than a planar design leading to better control of the current.
   #+end_quote
3. What are the six main categories of fabrication tools used in a
   semiconductor fab?
   #+begin_quote
   Mask-making, deposition, etching/planarization, ion implantation,
   cleaning, and metrology/inspection.

   In the video: Mask layer, adding, removing, modifying, cleaning and
   inspecting  material.
   #+end_quote
4. How does chip “binning” affect the product lines (e.g., i9, i7,
   i5)?
   #+begin_quote
   Chips with defects are categorized based on functional cores and
   features, sold under different product tiers.
   #+end_quote
5. Why is photolithography considered one of the most important steps
   in chip fabrication?
   #+begin_quote
   It transfers nanoscopic circuit patterns from photomasks onto
   wafers, enabling billions of identical transistors and wires.
   #+end_quote

** Summary: How are Microchips made? ([[https://youtu.be/dX9CGRZwD-w?si=KDARgJLQz7Bd3IEu][Branch Education, YouTube 2024]])

The video explains how modern microchips, containing billions of
nanoscopic transistors, are manufactured in semiconductor fabrication
plants:
- Scale & Complexity: A CPU may hold 26 billion transistors across 80
  layers of metal interconnects, manufactured in cleanrooms the size
  of eight football fields, using machines costing up to $170M.
- Transistor Structures: Modern CPUs use FinFET transistors, only tens
  of nanometers in size, smaller than dust particles or mitochondria.
- Manufacturing Analogy: Building a chip is like baking an 80-layer
  cake with 940 steps — requiring precision at every stage or the
  product fails.
- Core Process Steps: Each layer is built by depositing insulators,
  applying light-sensitive photoresist, using photolithography with UV
  light and masks, etching away unwanted areas, depositing copper, and
  leveling the wafer with chemical mechanical planarization
  (CMP). These steps are repeated layer by layer, with frequent
  cleaning and inspection.
- Fabrication Plant Tools: Six categories of tools are used:
  1. Mask-making (photoresist, lithography, stripping)
  2. Deposition (adding metals, oxides, silicon)
  3. Etching & planarization
  4. Ion implantation (doping regions for transistors)
  5. Wafer cleaning
  6. Metrology/inspection
- Throughput & Cost: A fab may hold 435 tools and produce 50,000
  wafers monthly. Each wafer, costing ~$100, becomes worth ~$100,000
  once populated with CPUs.
- Post-Fab Steps: Chips are tested and “binned” (e.g., i9, i7, i5)
  depending on defects, cut from wafers, mounted on packages, fitted
  with heat spreaders, and tested again before sale.
- Broader Context: Microchip fabrication is secretive and
  technologically advanced, requiring immense time and resources. The
  video notes future plans for deep dives on transistors, GPUs, and
  CPU architectures.

** Review: Making logic gates from transistors ([[https://youtu.be/sTu3LwpF6XI?si=k1DRLefz6b9OSKTu][Ben Eater, 2015]])

1. What are the three terminals of a transistor and what do they
   represent?
   #+begin_quote
   Emitter, Base, Collector. The base controls current flow between
   collector and emitter.

   #+attr_html: :width 400px :float nil:
   [[../img/transistor.png]]
   #+end_quote
2. What happens in the LED circuit when current flows from the base to
   the emitter?
   #+begin_quote
   The transistor switches on and allows a larger current from collector
   to emitter, lighting the LED.

   #+attr_html: :width 300px :float nil:
   [[../img/led.png]]
   #+end_quote
3. Which logic gate does a single transistor implement when it inverts the input?
   #+begin_quote
   A NOT gate (inverter): input ON → output OFF, input OFF → output ON.

   #+attr_html: :width 300px :float nil:
   [[../img/inverter.png]]

   #+end_quote
4. How is an AND gate built with two transistors?
   #+begin_quote
   The transistors are placed in series. Current flows and the LED turns
   on only if both are conducting (both inputs ON).

   #+attr_html: :width 300px :float nil:
   [[../img/and_circuit2.png]]

   #+end_quote
5. What is the difference between an OR gate and an XOR gate?
   #+begin_quote
   OR: output ON if one or both inputs are ON.  XOR: output ON only if
   exactly one input is ON (off when both are ON).

   #+attr_html: :width 300px :float nil:
   [[../img/or_circuit2.png]]

   #+attr_html: :width 300px :float nil:
   [[../img/xor_circuit2.png]]

   #+end_quote
** Summary: Making logic gates from transistors ([[https://youtu.be/sTu3LwpF6XI?si=k1DRLefz6b9OSKTu][Ben Eater, 2015]])
#+attr_html: :width 600px :float nil:
[[../img/all_gates.png]]

The video introduces transistors and shows how they can be used as
building blocks for digital logic.

- A transistor has three terminals: *emitter*, *base*, *collector*.
- A small base-to-emitter current controls a larger collector-to-emitter current:
  the transistor acts as a *switch*.
- Example 1: Push button + transistor turns an LED on or off.
- Example 2: A transistor can act as an *inverter (NOT gate)*: input ON → LED OFF,
  input OFF → LED ON.
- Combining transistors yields logic gates:
  - *AND gate*: LED on only if both inputs are on.
  - *OR gate*: LED on if either input is on.
  - *XOR gate*: LED on if exactly one input is on (requires five transistors).
- Other gates (NAND, NOR, XNOR, Buffer) can be built by adding inversion.
- With these gates, more complex circuits can be built for arithmetic,
  memory, and eventually entire computers.

** Assembly and the machine

1. Why Assembly at all?
   #+begin_quote
   Assembly is the key to machine-level execution:
   1. Behavior of programs with bugs
   2. Tuning program performance
   3. Implementing system software
   4. Creating/fighting malware
   #+end_quote

2. How can you generate an Assembly file from a C file =hello.c=?
   #+begin_example
   g++ -S hello.c -o hello.s  # output = Assembly
   #+end_example

3. How can you look at the Assembly file?
   #+begin_quote
   With any text editor, or with ~cat~ on the command-line.
   #+end_quote

4. How must you compile to debug your file =segfault.c=?
   #+begin_example
   g++ -g segfault.c -o segfault  # output = Ready for gdb
   #+end_example

5. How can you debug the object code =segfault= with ~gdb~?
   #+begin_example
   gdb segfault  # import segfault and run it in gdb
   #+end_example

* Week 3: Memory, Compiler chain (Sep 8, 10, 12)

- [X] Guest speaker on Wednesday 10 Sept 1 pm in Derby 255
- [X] Memory layout errors
- [X] Code optimization
- [X] Network dependency

- [X] The compiler chain
- [ ] Hardware organization
- [ ] Running the =hello world= executable

- [ ] The OS and its abstractions
- [ ] The memory organization
- [ ] Amdahl's Law
- [ ] Networks
- [ ] Concurrency and parallelism

** Review: Memory (Monday)

1. What's an architecture problem related to memory?
   #+begin_quote
   Memory: Out-of-bounds access can corrupt nearby data because memory
   must be explicitly allocated and managed.
   #+end_quote
2. What's an architecture problem related to performance?
   #+begin_quote
   Performance: Poor memory access patterns (like column-wise instead
   of row-wise) increase cache misses and slow programs.
   #+end_quote
3. What's an architecture problem related to networks?
   #+begin_quote
   Networks: Concurrency, unreliable media, and cross-platform
   differences make network programming complex despite standard
   libraries.
   #+end_quote
4. What's a socket?
   #+begin_quote
   A socket is an endpoint for communication between two programs over
   a network (including communication of a computer with itself). On
   Unix-like systems (Linux, MacOS) it's like a file descriptor - you
   can read from and write to it, but instead of accessing a file, the
   data go through the network stack.
   #+end_quote
5. What's the little/big endian problem?
   #+begin_quote
   The little/big endian problem is about how multi-byte data (like an
   ~int~ or ~double~) is stored in memory:
   - *Little-endian*: the least significant byte goes in the lowest
     memory address.
   - *Big-endian:* the most significant byte goes in the lowest memory
     address.

   The "problem" arises when data is shared between systems with
   different endianness (e.g., over a network or in files). The same
   bytes can be interpreted differently unless both sides agree on the
   byte order.

   In practice, this means that a 32-bit instruction like =0x00c58533=
   on a little endian machine will appear in memory as: =33 85 c5 00=.
   #+end_quote

** Review: Compiler chain (Wednesday)

1. What does ~make~ do? Example use?
   #+begin_quote
   ~make~ works with a configuration ~Makefile~ to compile code. An
   example is =make hello= on the command-line which uses the default
   ~Makefile~ to run =gcc hello.c -o hello= and generate an executable
   =hello= from the source file =hello.c=.
   #+end_quote

2. What is shipped alongside software source code to enable portable
   object code?
   #+begin_quote
   A build system or ~Makefile~. The compiler uses the ~Makefile~ to build
   the software for the given computer architecture.

   Portable object code = source code + Makefile/configuration.
   #+end_quote

3. Why does each character in =hello.c= have an associated number like
   104 for =h=? What does this have to do with bytes?
   #+begin_quote
   Because text is stored as bytes using ASCII encoding: each
   character is mapped to a unique integer between 0 and 255
   (2^8-1). For example, the letter =A= is ASCII =65= which in binary is
   =01000001= (2^6+1). One ASCII character = 1 byte (8 bits) in memory.
   #+end_quote

4. What does the preprocessor do in the compilation chain?
   #+begin_quote
   The preprocessor expands macros (like =#define PI 3.14=) and includes
   header files (like =#include <stdio.h>=) to create an intermediate
   (=.i=) source file.
   #+end_quote

5. In the compilation chain, what is the role of the assembler?
   #+begin_quote
   The assembler translates assembly code (=.s=) into object code
   (=.o=). With ~gdb~, you can disassemble the object machine code to see
   the assembly (as text =.s=).
   #+end_quote  

  #+attr_html: :width 00px :float nil:
  #+caption: Compilation chain. Source: Bryant/O'Halloran 2016 (Fig 1.3)
  [[../img/fig1.3_compilation.png]]

* Week 4: Expo, Hardware Organization, Operating System (Sep 15, 17, 19)
#+attr_html: :width 200px :float nil:
[[../img/expo.png]]

*Housekeeping:*

- [X] I made the first assignment (memory out-of-bounds demonstration)
  a little more verbose and a little simpler. If you didn't submit on
  time or you don't understand it: Ask another student, submit late
  for 50%.

- [X] Test 3 is live (25 questions).

- [ ] Two assignments are live - compiler chain and
  makefile. Unfortunately, Canvas allows only upload of one file or
  text. If you cannot fit the output on a screenshot, you need to
  submit a ZIP file.
  
- [X] For the ~Makefile~ assignment, just submit the results as text -
  copy of the Makefile and copy of the command-line dialogue. Like this:
  #+attr_html: :width 400px:
  [[../img/makefile.png]]

- [X] You should go to the Career Fair tomorrow. Will you?

- [ ] *What did you think of the Career Fair?*

*Content:*

- [X] Hardware organization
- [ ] Operating system and hardware
- [ ] Networks and hardware
- [ ] Amdahl's Law (a law about systems)
- [ ] Concurrency and parallelism

** DONE Review: Compiler chain / Makefile

1. What kind of file does the compiler (~cc1~) produce?  
   #+begin_quote
   Assembly source code (.s) for the target machine architecture.  
   #+end_quote

2. What is the role of the assembler (~as~)?  
   #+begin_quote
   It translates assembly code (.s) into an object file (.o) containing
   machine code instructions.  
   #+end_quote

3. What does the linker (~ld~) do?  
   #+begin_quote
   It combines object files (.o) and library code into a final
   executable file.  
   #+end_quote

4. What is the purpose of a Makefile?  
   #+begin_quote
   It automates the build process by defining rules, dependencies, and
   commands to compile programs efficiently.  
   #+end_quote

5. What happens if you run =make hello= and =hello.o= is already up to
   date (i.e. the timestamp of =hello.o= is more recent than =hello.c=)?
   #+begin_quote
   Nothing is rebuilt, because ~make~ sees that the target is newer than
   its dependencies.  
   #+end_quote

6. Does ~make~ only work on C programs, or also on C++ programs? And
   what about Python or R? What about Java?
   #+begin_src bash :results output
     echo -e "#include <iostream>\nint main(){std::cout<<\"hello\";return 0;}" > hello.cpp
     cat hello.cpp
     make hello  # uses the default Makefile
   #+end_src

   #+RESULTS:
   : #include <iostream>
   : int main(){std::cout<<"hello";return 0;}
   : g++     hello.cpp   -o hello

   #+begin_src bash :results output
     echo -e "str(mtcars)" > mtcars.R
     cat mtcars.R
     make mtcars
     Rscript ./mtcars.R
   #+end_src

   #+RESULTS:
   #+begin_example
   str(mtcars)
   'data.frame':	32 obs. of  11 variables:
    $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
    $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
    $ disp: num  160 160 108 258 360 ...
    $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
    $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
    $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
    $ qsec: num  16.5 17 18.6 19.4 17 ...
    $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
    $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
    $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
    $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
   #+end_example

   #+begin_src bash :results output
     echo -e "print(\"hello\")" > hellopy.py
     cat hellopy.py
     make hellopy
     #python3 hellopy.py
   #+end_src

   #+RESULTS:
   : print("hello")

   #+begin_src bash :results output
     echo -e "System.out.println(\"hello\");" > helloJava.java
     cat helloJava.java
     make helloJava
   #+end_src

   #+RESULTS:
   : System.out.println("hello");

7. How must commands in a Makefile begin?
   #+begin_quote
   The =make= utility expects commands in each rule to be indented with
   a TAB character, not spaces — otherwise it throws an error.
   #+end_quote

8. How does =make clean= typically work?
   #+begin_quote
   It removes intermediate files (like .i, .s, .o, executables) so you
   can rebuild from scratch.  
   #+end_quote
   
9. Which devices are involved in running a simple program like =hello=?
   #+begin_quote
   Execution requires cooperation between CPU, memory, input/output
   system, graphics/display system, and keyboard for interaction.
   #+end_quote

10. What is a =checksum=?
    #+begin_quote
    A *checksum* is a fixed-size value that is sent/store alongside with
    data, for example precompiled software. At the receiving end, the
    checksum is recomputed and compared with the sent/stored one. If
    the values don't match, the data was likely corrupted or tampered
    with.
    #+end_quote

11. What do the commands =echo $PS1= and =echo $SHELL= mean and return
    (only on Linux)?
    #+begin_example sh
      ## shell prompt definition string variable
      echo $PS1     # on my laptop: \u@marcus@dell:\w $
      ## shell environment variable
      echo $SHELL   # /bin/bash
    #+end_example

** Review: Hardware Organization

1. What is the main role of a bus in computer hardware organization?
   #+begin_quote
   A bus acts as a bridge that carries data back and forth between
   system components, typically designed for byte transfers (8-bit
   chunks on a 64-bit system).
   #+end_quote

2. How are controllers and adapters different in connecting devices to
   the I/O bus?
   #+begin_quote
   A controller is a *chip* located directly *on the device* (e.g., USB
   controller on keyboard), while an adapter is a separate *card* that
   *plugs* into the motherboard (e.g., graphics adapter, WiFi adapter).
   #+end_quote

3. What are the four basic CPU transactions, and what do they accomplish?
   #+begin_quote
   1. Load: copy a byte from main memory into a register.  
   2. Store: copy a byte from a register into main memory.  
   3. Operate: perform arithmetic/logic using ALU and registers.  
   4. Jump: copy a value into the program counter to change execution
      flow.
   #+end_quote

4. What role does CMOS play in a computer system?
   #+begin_quote
   CMOS stores system configuration data (such as BIOS settings, date,
   and time) using a small battery so that the information persists
   even when the computer is powered off.
   #+end_quote

5. Why is main memory (RAM) considered temporary storage, and what
   does it physically consist of?
   #+begin_quote
   RAM is temporary storage because its contents (code and data) are
   lost when power is off. Physically, it consists of DRAM chips.
   #+end_quote
