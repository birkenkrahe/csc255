#+TITLE:Boolean Logic Gates and Hardware Description Language
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:CSC 255 Computer Architecture Lyon College
#+OPTIONS: toc:1 num:1 ^:nil
#+PROPERTY: header-args:R :session *R* :results output :exports both :noweb yes
#+PROPERTY: header-args:python :session *Python* :results output :exports both :noweb yes
#+PROPERTY: header-args:C :main yes :includes <stdio.h> :results output :exports both :noweb yes
#+PROPERTY: header-args:C++ :main yes :includes <iostream> :results output :exports both :noweb yes
#+STARTUP: overview hideblocks indent entitiespretty:
* Boolean Logic (Popquiz)
** Boolean values and basic operations

- Boolean values: 0/1, on/off, true/false, high/low etc.

- Basic operations:

  1) (x AND y) or: =x \land y=

  2) (x OR y) or: =x \lor y=

  3) NOT(x) or: =\notx=

** Boolean expressions

- Boolean expressions are combinations of the basic operations that
  evaluate to a Boolean value.

- Example: NOT(0 OR (1 AND 1)) = NOT(0 OR 1) = NOT(1) = 0

- Question: What is the result of 1 AND (0 OR (NOT(1)))?
  #+begin_quote
  Answer: 1 AND (0 OR (NOT(1))) = 1 AND (0 OR 0) = 1 AND 0 = 0
  #+end_quote

** Boolean functions:

- Formula:
  #+begin_example
  f(x,y,z) = (x AND y) OR (NOT(x) AND z)
  #+end_example

- Challenge: Program this function and confirm this result:
  #+name: boolean function table
  | x | y | z | f(x,y,z) |
  |---+---+---+----------|
  | 0 | 0 | 0 |        0 |
  | 0 | 0 | 1 |        1 |
  | 0 | 1 | 0 |        0 |
  | 0 | 1 | 1 |        1 |
  | 1 | 0 | 0 |        0 |
  | 1 | 0 | 1 |        0 |
  | 1 | 1 | 0 |        1 |
  | 1 | 1 | 1 |        1 |

- The *truth table* and the *formula* or *function* are two completely
  equivalent ways to describe the situation.

- Solution:
  #+begin_src C++ :main no :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    bool f(bool x, bool y, bool z);

    int main()
    {
      vector<bool> v {0,1};
      for (bool x : v)
        for (bool y : v)
          for (bool z : v)
            cout << f(x,y,z);
      return 0;
    }

    bool f(bool x, bool y, bool z)
    {
      return ((x && y) || (!(x) && z));
    }
  #+end_src

  #+RESULTS:
  : 01010011

- Bonus: Modify your solution to print the [[boolean function table]].

- Bonus solution:
  #+begin_src C++ :main no :includes <iomanip> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    bool f(bool x, bool y, bool z);

    int main()
    {
      vector<bool> v {0,1};

      cout << "| x | y | z | f(x,y,z) |\n"
           << "|---|---|---|----------|\n";
      for (bool a : v) {
        for (bool b : v)
          for (bool c : v)
            cout << "| " << a << " | " << b << " | " << c << " |"
                 << right << setw(9) << f(a,b,c) << " |" << endl;
      }
      return 0;
    }

    bool f(bool x, bool y, bool z)
    {
      return ((x && y) || (!(x) && z));
    }
  #+end_src

  #+RESULTS:
  #+begin_example
  | x | y | z | f(x,y,z) |
  |---|---|---|----------|
  | 0 | 0 | 0 |        0 |
  | 0 | 0 | 1 |        1 |
  | 0 | 1 | 0 |        0 |
  | 0 | 1 | 1 |        1 |
  | 1 | 0 | 0 |        0 |
  | 1 | 0 | 1 |        0 |
  | 1 | 1 | 0 |        1 |
  | 1 | 1 | 1 |        1 |
  #+end_example

- How many states does a function of 5 arguments have?
  #+begin_quote
  There are 2^{3} = 8 possible ways to distribute 2 (binary) values over
  three places with replacement (that is being able to use the same
  values again). Therefore, distributing 2 values over 5 arguments
  gives 2^{5} = 32 states.
  #+end_quote

** Boolean identities

- Commutative laws for binary operators AND, OR:
  #+begin_example
  (x AND y) = (y AND x)
  (x OR y)  = (y OR x)
  #+end_example

- Associative laws:
  #+begin_example
  x AND (y AND z) = (x AND y) AND (x AND z)
  x OR (y OR z) = (x OR y) OR (x OR z)
  #+end_example

- Distributive laws both over AND and OR
  #+begin_example
  x AND (y OR z) = (x AND y) OR (x AND z)
  x OR (y AND z) = (x OR y) AND (x OR z)
  #+end_example

- De Morgan laws:
  #+begin_example
  NOT(x AND y) = NOT(x) OR NOT(y)
  NOT(x OR y) = NOT(x) AND NOT(y)
  #+end_example

- Idempotence:
  #+begin_example
  a AND a = a
  a OR a = a
  NOT(NOT(a)) = a    ("double negation")
  #+end_example

- Tautology:
  #+begin_example
  NOT(a) OR a = TRUE
  NOT(a) AND a = FALSE
  #+end_example

- The tautology is useful when simplifying expressions:
  | Expression  | Result | Explanation                      |
  |-------------+--------+----------------------------------|
  | A AND TRUE  | A      | TRUE doesn’t affect the outcome  |
  | A OR TRUE   | TRUE   | TRUE dominates in OR             |
  | A AND FALSE | FALSE  | FALSE dominates in AND           |
  | A OR FALSE  | A      | FALSE doesn’t affect the outcome |

- *Exercise* Prove the distributive laws using code by building the
  truth table for the left and the right hand side of each expression.

** Example: Using the Boolean algebra laws

- Instead of proof by coding, you can also prove algebraically using
  the applicable laws.

- Example: Use the laws to simplify (write down which law you used)
  #+begin_example
  NOT(NOT(x) AND NOT(x OR y))
  #+end_example

- Solution:
  #+begin_example
  NOT(NOT(x) AND NOT(x OR y)) =            De Morgan
  NOT(NOT(x) AND NOT(x) AND NOT(y)) =      Associativity
  NOT((NOT(x) AND NOT(x)) AND NOT(y)) =    Idempotence
  NOT(NOT(x) AND NOT(y)) =                 De Morgan
  NOT(NOT(x)) OR NOT(NOT(y)) =             Double negation/Idempotence
  x OR y
  #+end_example

- Confirm this with code!
  #+begin_quote
  Use the code above for f1(x,y) and return =(x || y)=, and for f2(x,y),
  use: =!(!x && !(x || y))=.
  #+end_quote

- Solution:
  #+begin_src C++ :main no :includes <iomanip> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    bool f1(bool x, bool y);
    bool f2(bool x, bool y);

    int main()
    {
      vector<bool> v {0,1};

      cout << "| x | y | f1 | f2 |\n"
           << "|---|---|---------|\n";
      for (bool a : v) {
        for (bool b : v)
          cout << "| " << a << " | " << b << " | "
           << right << setw(2) << f1(a,b) << " | "
           << right << setw(2) << f2(a,b) << " |" << endl;
      }
      return 0;
    }

    bool f1(bool x, bool y)
    {
      return (x||y);
    }
    bool f2(bool x, bool y)
    {
      return (!(!x && !(x || y)));
    }
  #+end_src

  #+RESULTS:
  : | x | y | f1 | f2 |
  : |---|---|---------|
  : | 0 | 0 |  0 |  0 |
  : | 0 | 1 |  1 |  1 |
  : | 1 | 0 |  1 |  1 |
  : | 1 | 1 |  1 |  1 |

- Challenge: Put the printing into a function =print= that takes a
  vector as an argument.
  #+begin_src C++ :main no :includes <iomanip> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    bool f1(bool, bool);
    bool f2(bool, bool);
    void print(vector<bool>);

    int main()
    {
      vector<bool> v {0,1};
      print(v);
      return 0;
    }

    bool f1(bool x, bool y)
    {
      return (x||y);
    }
    bool f2(bool x, bool y)
    {
      return (!(!x && !(x || y)));
    }
    void print(vector<bool> v)
    {
      cout << "| x | y | f1 | f2 |\n"
           << "|---|---|---------|\n";
      for (bool x : v) {
        for (bool y : v)
          cout << "| " << x << " | " << y << " | "
               << right << setw(2) << f1(x,y) << " | "
               << right << setw(2) << f2(x,y) << " |" << endl;
      }
    }
  #+end_src

  #+RESULTS:
  : | x | y | f1 | f2 |
  : |---|---|---------|
  : | 0 | 0 |  0 |  0 |
  : | 0 | 1 |  1 |  1 |
  : | 1 | 0 |  1 |  1 |
  : | 1 | 1 |  1 |  1 |

** Mathematical excursion: Algebras, rings, and groups

- "Boolean algebra" is not an algebra in the strict mathematical
  sense.

- You can reinterpret it as a *Boolean commutative ring with
  characteristic 2*, if you define XOR as addition and AND as
  multiplication:
  #+begin_example
  a + b = (a \lor b) \land \not (a \land b)
  a * b = a \land b
  #+end_example

- Here, addition is commutative and associative (because AND and OR
  are), and has an identity (0):
  #+begin_example
  a + b = b + a
  a + (b + c) = (a + b) + c
  0 + 0 = 0 \land 1 = 0
  #+end_example

- Every element is its own inverse: a + a = 0 (by definition since XOR
  is 0 when the operands are identical) - that's "characteristic 2".
  #+begin_example
  a + a = (a \lor a) \land \not (a \land a) = a XOR a = 0
  #+end_example

- Multiplication is associative and distributes over addition:
  #+begin_example
  a * (b * c) = a AND (b AND c) = (a AND b) AND c = (a + b) + c
  a * (b + c) = a AND (b XOR c) = (a AND b) XOR (a AND c)
  #+end_example

- The distributive law should be shown, it's perhaps not directly
  obvious:
  #+begin_example
  a AND (b XOR c) = (a AND b) XOR (a and c)
  #+end_example

- Truth table from program for all values a,b,c in {0,1} where
  1) f1(x,y,z) = x AND (y XOR z)
     = x AND ((y OR z) AND NOT(y AND z))
  2) f2(x,y,z) = (x AND y) XOR (x AND z)
     = ((x AND y) OR (x AND z)) AND NOT((x AND y) AND (x AND z))

- Code:
  #+begin_src C++ :main no :includes <iomanip> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    bool f1(bool x, bool y, bool z);
    bool f2(bool x, bool y, bool z);

    int main()
    {
      vector<bool> v {0,1};

      cout << "| x | y | z | f1 | f2 |\n"
           << "|---|---|---|---------|\n";
      for (bool a : v) {
        for (bool b : v)
          for (bool c : v)
            cout << "| " << a << " | " << b << " | " << c << " |"
                 << right << setw(3) << f1(a,b,c) << " |"
                 << right << setw(3) << f2(a,b,c) << " |" << endl;
      }
      return 0;
    }

    bool f1(bool x, bool y, bool z)
    {
      return (x && ((y || z) && !(y && z)));
    }
    bool f2(bool x, bool y, bool z)
    {
      return (((x && y) || (x && z)) && !((x && y) && (x && z))    );
    }
  #+end_src

  #+RESULTS:
  #+begin_example
  | x | y | z | f1 | f2 |
  |---|---|---|---------|
  | 0 | 0 | 0 |  0 |  0 |
  | 0 | 0 | 1 |  0 |  0 |
  | 0 | 1 | 0 |  0 |  0 |
  | 0 | 1 | 1 |  0 |  0 |
  | 1 | 0 | 0 |  0 |  0 |
  | 1 | 0 | 1 |  1 |  1 |
  | 1 | 1 | 0 |  1 |  1 |
  | 1 | 1 | 1 |  0 |  0 |
  #+end_example

- *Challenge:* Overload the ~&&~ and ~||~ operators so that you can use =AND=
  and =OR= instead.

- Finally, Under XOR, the set {0,1} forms an *Abelian group* with the
  identity 0:
  #+begin_example
  0 XOR 0 = 0
  a XOR a = 0
  #+end_example

** Brilliant question
#+attr_html: :width 400px :float nil:
[[../img/brilliant.png]]

This image was taken from the brilliant.org course on "Digital Logic".

Test this with code:
#+begin_src C++ :main no :includes <iomanip> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
  bool f1(bool, bool);
  bool f2(bool, bool);
  void print(vector<bool>);

  int main()
  {
    vector<bool> v {0,1};
    print(v);
    return 0;
  }

  bool f1(bool x, bool y)
  {
    return ((!x && y) || (x && !y)); // XOR
  }
  bool f2(bool x, bool y)
  {
    return ((x || y) && !(x && y));
  }
  void print(vector<bool> v)
  {
    cout << "| x | y | f1 | f2 |\n"
         << "|---|---|---------|\n";
    for (bool x : v) {
      for (bool y : v)
        cout << "| " << x << " | " << y << " | "
             << right << setw(2) << f1(x,y) << " | "
             << right << setw(2) << f2(x,y) << " |" << endl;
    }
  }
#+end_src

#+RESULTS:
: | x | y | f1 | f2 |
: |---|---|---------|
: | 0 | 0 |  0 |  0 |
: | 0 | 1 |  1 |  1 |
: | 1 | 0 |  1 |  1 |
: | 1 | 1 |  0 |  0 |

* Boolean Function Synthesis (normal forms)

- There are three agents: The truth table (state space), the Boolean
  expression (function), and finally the digital circuit (physics).

- We've looked at getting from the function to the table, now we're
  going to look at the opposite: Generating a Boolean expression from
  a truth table.

- Example:
  1) Only focus on rows with f = true.
  2) Devise a function that fulfils the equation for that row:
     Translate every 0 into a NOT(), and every 1 into a variable.
  3) These functions get the value of 1 only for that row, and the
     value of 0 for every other combination (by design).

  | x | y | z | f |                              |
  |---+---+---+---+------------------------------|
  | 0 | 0 | 0 | 1 | NOT(x) AND NOT(y) AND NOT(z) |
  | 0 | 0 | 1 | 0 |                              |
  | 0 | 1 | 0 | 1 | NOT(x) AND y AND NOT(z)      |
  | 0 | 1 | 1 | 0 |                              |
  | 1 | 0 | 0 | 1 | x AND NOT(y) AND NOT(z)      |
  | 1 | 0 | 1 | 0 |                              |
  | 1 | 1 | 0 | 0 |                              |
  | 1 | 1 | 1 | 0 |                              |

- So now concatenate all of these combined with OR.

- Verify this with the code we've written, for the function:
  #+begin_example
  (NOT(x) AND NOT(y) AND NOT(z)) ||
  (NOT(x) AND y AND NOT(z)) ||
  (x AND NOT(y) AND NOT(z))
    #+end_example
  Or in C++:
  #+begin_example C++
  (!x  && !y && !z) || (!x && y && !z || (x && !y &&  !z)
  #+end_example
  The code:
  #+begin_src C++ :main no :includes <iomanip> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    bool f(bool x, bool y, bool z);

    int main()
    {
      vector<bool> v {0,1};

      cout << "| x | y | z | f(x,y,z) |\n"
           << "|---|---|---|----------|\n";
      for (bool a : v) {
        for (bool b : v)
          for (bool c : v)
            cout << "| " << a << " | " << b << " | " << c << " |"
                 << right << setw(9) << f(a,b,c) << " |" << endl;
      }
      return 0;
    }

    bool f(bool x, bool y, bool z)
    {
      return ((!x  && !y && !z) || (!x && y && !z) || (x && !y &&  !z));
    }
  #+end_src

  #+RESULTS:
  #+begin_example
  | x | y | z | f(x,y,z) |
  |---|---|---|----------|
  | 0 | 0 | 0 |        1 |
  | 0 | 0 | 1 |        0 |
  | 0 | 1 | 0 |        1 |
  | 0 | 1 | 1 |        0 |
  | 1 | 0 | 0 |        1 |
  | 1 | 0 | 1 |        0 |
  | 1 | 1 | 0 |        0 |
  | 1 | 1 | 1 |        0 |
  #+end_example

- The expression can be simplified:
  #+begin_example
  (!x && !y && !z) || (!x && y && !z) || (x && !y && !z) =
  [(!x && !y) || (!x && y) || (x && !y)] && !z =
  [ !x && (!y || y)        || (x && !y)] && !z =
  [ !x || (x && !y)] && !z =
  [(!x || x) && (!x || !y)] && !z =
  (!x || !y) && !z
  #+end_example

- Check that with the program (enlarged for three Boolean variables):
  #+begin_src C++ :main no :includes <iomanip> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    bool f1(bool, bool, bool);
    bool f2(bool, bool, bool);
    void print(vector<bool>);

    int main()
    {
      vector<bool> v {0,1};
      print(v);
      return 0;
    }

    bool f1(bool x, bool y, bool z)
    {
      return ((!x || !y) && !z);
    }
    bool f2(bool x, bool y, bool z)
    {
      return ((!x  && !y && !z) || (!x && y && !z) || (x && !y &&  !z));
    }
    void print(vector<bool> v)
    {
      cout << "| x | y | z | f1 | f2 |\n"
           << "|---|---|---|---------|\n";
      for (bool x : v) {
        for (bool y : v)
          for (bool z : v)
        cout << "| " << x << " | " << y << " | " << z << " | "
             << right << setw(2) << f1(x,y,z) << " | "
             << right << setw(2) << f2(x,y,z) << " |" << endl;
      }
    }
  #+end_src

  #+RESULTS:
  #+begin_example
  | x | y | z | f1 | f2 |
  |---|---|---|---------|
  | 0 | 0 | 0 |  1 |  1 |
  | 0 | 0 | 1 |  0 |  0 |
  | 0 | 1 | 0 |  1 |  1 |
  | 0 | 1 | 1 |  0 |  0 |
  | 1 | 0 | 0 |  1 |  1 |
  | 1 | 0 | 1 |  0 |  0 |
  | 1 | 1 | 0 |  0 |  0 |
  | 1 | 1 | 1 |  0 |  0 |
  #+end_example

- *Challenge*: It would be cool to have the function be parsed into the
  code as input from the commandline so as to use the same executable!

* Computability

*Verifiability* of a Boolean formula for a given assignment to its
variables is a formula evaluation and it can be done in polynomial
time (plug in and compute). This is in P (solvable efficiency).

*Satisfiability* of a Boolean formula is an NP-complete problem: Is
there any assignment of values to the variables that makes the formula
true?

This is an NP-complete problem:
1. It is in NP because you can verify a given assignment in polynomial time
2. It is NP-complete because every problem in NP can be reduced to it
   in polynomial time.

| Problem                   | In class    | Why                              |
|---------------------------+-------------+----------------------------------|
| Evaluate formula on input | P           | Direct computation is fast       |
| Verify a solution         | P           | Just evaluate with given input   |
| Find a satisfying input   | NP-Complete | Requires search over assignments |

* Only NOT and AND are needed

Theorem:
#+begin_quote
Any Boolean function can be represented using an expression containing
Boolean AND, OR, and NOT operations.
#+end_quote

In fact, to construct digital circuits, we only need two of these -
NOT and AND, or NOT and OR because we can compute an OR with NOT and AND.

| x | y | x OR y | f            |
|---+---+--------+--------------|
| 0 | 0 |      0 |              |
| 0 | 1 |      1 | NOT(x) AND y |
| 1 | 0 |      1 | x AND NOT(y) |
| 1 | 1 |      1 | x AND y      |

Simplify the expression:
#+begin_example
(NOT(x) AND y) OR (x AND NOT(y)) OR (x AND y) =
(NOT(x) AND y) OR (x AND (NOT(y) AND y)) =
(NOT(x) AND y) OR x =
(NOT(x) OR x) AND (x OR y) =
x OR y
#+end_example

That didn't get us very far. We don't just need to simplify (we know
the answer to that) but eliminate OR if we can! The answer is simply
given in the form of the De Morgan identity:
#+begin_example
(x OR y) = NOT(NOT(x) AND NOT(y))
#+end_example

* The NAND function

- Truth table for NOT(x AND y) = x NAND y
  | x | y | NAND |
  |---+---+------|
  | 0 | 0 |    1 |
  | 0 | 1 |    1 |
  | 1 | 0 |    1 |
  | 1 | 1 |    0 |

- What would be the logical equivalent of NAND(x,x)?
  #+begin_example
  NAND(x,x) = NOT ( x AND x) = NOT(x)
  #+end_example

- Theorem:
  #+begin_quote
  Any Boolean function can be represented using an expression
  containing only NAND operations.
  #+end_quote

- Proof:
  1) Express NOT with NAND
     #+begin_example
     NOT(x) = NOT(x AND x) = (x NAND x)
     #+end_example
     #+attr_html: :width 400px :float nil:
     [[../img/nandx.png]]

  2) Express AND with NAND
     #+begin_example
     (x AND y) = NOT(NOT(x AND y)) = NOT(x NAND y)
     #+end_example

* Logic Gates

- Gate logic is a technique for implementing Boolean functions using
  basic building blocks of digital circuits (electronic devices that
  take binary input and produce binary output).

- Each of the elementary logic gates can be represented uniquely by:
  1) A gate or circuit diagram (in->out)
  2) A functional specification (if-then-else)
  3) A truth table (state space)

- All of these descriptions are fully equivalent: They are
  abstractions. We said nothing about how the gate is built or
  implemented as an electronic part or a chip.

* NAND gate

- Elementary logic gates: NAND

  1) Gate diagram:
     #+attr_html: :width 400px :float nil:
     #+caption: NAND gate (LogiSim)
     [[../img/NAND.png]]

  2) Functional specification:
     #+begin_example
     if (a==1 and b==1)
     then out=0 else out=1
     #+end_example

  3) Truth table:

     | a | b | out |
     |---+---+-----|
     | 0 | 0 |   1 |
     | 0 | 1 |   1 |
     | 1 | 0 |   1 |
     | 1 | 1 |   0 |

* AND gate
#+attr_html: :width 400px :float nil:
#+caption: AND gate (LogiSim)
[[../img/AND_gate.png]]
#+begin_example
if (a==1 and b ==1)
then out=1 else out=0
#+end_example

* OR gate
#+attr_html: :width 400px :float nil:
#+caption: OR gate (LogiSim)
[[../img/OR_gate.png]]
#+begin_example
if (a==1 or b ==1)
then out=1 else out=0
#+end_example

* NOT gate:
#+attr_html: :width 400px :float nil:
#+caption: NOT gate (LogiSim)
[[../img/NOT_gate.png]]
#+begin_example
if (in==0)
then out=1 else out=0
#+end_example

* Composite gates: An example
#+attr_html: :width 400px :float nil:
#+Caption: Composite AND gate (interface)
[[../img/composite.png]]

#+begin_example
if (a==1 and b==1 and c==1)
   then out=1 else out=0
#+end_example

- Does the order of the input matter for this composite gate? Do you
  get a different result when swapping b and c for example?
  #+begin_quote
  No, because of associativity, as you can see from the functional
  description.
  #+end_quote

- To realize this gate as a diagram, you need to connect two AND gates
  as shown here: The dashed box in the figure shows the *interface* of
  this chip, which is what the user sees: Three inputs, one output.
  #+attr_html: :width 400px :float nil:
  #+caption: Composite AND operator (implementation)
  [[../img/composite2.png]]

- The *interface* (aka specification) is the gate's abstraction and
  answers the question "What does it do?" The inside is the gate's
  *implementation* and answers the question "How does it work?"

- Do you recognize this interface/implementation concept?
  #+begin_quote
  Data structures: ~public~ member functions of a ~class~ are interface
  (visible and usable in ~main~), while ~private~ member data are
  implementation, and can only accessed through the functions.

  All objects (e.g. cars): steering wheel is interface (usable),
  steering column is implementation (hidden).
  #+end_quote

- There should be only one way to describe the gate while there may be
  many ways to implement it: One abstraction, many implementations.

- To describe the electric circuit behind this, a different
  diagrammatic language is used: When relays or switches A and B are
  closed, electric current (originating at the battery on the left)
  flows through the circuit and the lamp is ON (out = 1).
  #+attr_html: :width 400px :float nil:
  #+caption: AND gate electric circuit [implementation]
  [[../img/AND_circuit.png]]

- To describe the electric circuit behind the OR gate, this diagram
  can be used: When either of the switches A or B is latched, current
  flows and the lamp turns ON.
  #+attr_html: :width 400px :float nil:
  #+caption: OR gate electric circuit [implementation]
  [[../img/OR_circuit.png]]

- And here is the diagram for the composite gate shown earlier:
  #+attr_html: :width 400px :float nil:
  #+caption: AND (a,b,c) circuit [implementation]
  [[../img/COMPOSITE_circuit.png]]

  #+begin_example
  if (a==1 and b==1 and c==1)
     then out=1 else out=0
  #+end_example

- We will not deal with physical implementations (electrical
  engineering) but only with the abstractions ([[https://youtu.be/sTu3LwpF6XI?si=k1DRLefz6b9OSKTu][see video though]]).

- Summary:

  1. The chip *interface* describes what the chip is doing; the chip
     *implementation* specifies how the chip is doing it.

  2. There are many possible implementations for every interface.

  3. The user of the chip is interested in the chip interface, the
     builder of the chip is interested in the chip implementation.

* Hardware Description Language (HDL)
#+attr_html: :width 600px :float nil:
#+caption: XOR gate interface (left) and possible implementation (right).
[[../img/XOR_gate.png]]

- A chip architect needs a complete and exact description of its
  function (through an interface diagram + truth table or +
  description, or an implementation diagram with inside view).

- The following question links logic theory (Boolean equivalence),
  circuit design (how XOR differs from AND and OR), and verification
  practice (testing correctness in the simulator).

- Which of these statements is true?
  - [X] The XOR gate outputs 1 if and only if its two input bits are
    not equal.

  - [ ] The XOR gate's output differs from the AND gate's output on
    all possible inputs.

  - [X] The XOR gate outputs 0 if and only if the sum of the input
    bits is an even number.

  - [X] The XOR gate's output differs from the OR gate's output only
    on the input a=1, b=1.

- Using the description or the truth table, you can begin to describe
  the hardware implementation (called a "stub file" or "contract"):
  #+name: stub file
  #+begin_example C
    /** XOR gate: out = (a AND NOT(b)) OR (NOT(A) AND B)) **/
    CHIP XOR {   // chip name
                 // Logic elements:
      IN a,b;    // input
      OUT out;   // output

      PARTS:     // Design elements:
      // Implementation missing
    }
  #+end_example

* Design: From requirements to gate diagram

- We're not building the chip from scratch: Let's assume that we
  already built an AND, a NOT, and an OR gate to use.

- XOR is defined by: out=1 when a AND NOT(b) OR b AND NOT(a).

- Next step: Gate logic diagram. Notice how the diagram translates the
  definition faithfully.
  #+attr_html: :width 600px :float nil:
  #+caption: XOR gate diagram
  [[../img/XOR_gate_diagram.png]]

- From gate diagram to HDL:

  1) Draw the gate interface: Outside of the boundary is the user's
     view - inputs a,b deliver XOR output out.

  2) When you use off-the-shelf gates, you have no freedom with regard
     to the inputs or outputs. The interface is given to us.

  3) Every connection that you use has to be named. In the diagram,
     the connections between AND and OR can be named according to the
     input lines:
     #+begin_example
     w1 = aAndNotb
     w2 = notaAndb
     #+end_example

4) We describe the diagram one chip part at a time:
   #+name: stub file
   #+begin_example C
   /** XOR gate: out = (a AND NOT(b)) OR (NOT(A) AND B)) **/
   CHIP XOR {   // chip name
                // Logic elements:
     IN a,b;    // input
     OUT out;   // output

     PARTS:     // Design elements:
     Not (in=a, out=nota); // lower NOT
     Not (in=b, out=notb); // upper NOT
     And (a=a, b=notb, out=aAndNotb); // upper AND
     And (a=nota, b=b, out=notaAndb); // lower AND
     Or  (a=aAndNotb, b=notaAndb, out=out);
   }
   #+end_example

* HDL characteristics

HDL is a functional/declarative language:
- HDL programs need to be well documented and readable.
- HDL chip and connections need to be appropriately named.
- Indentation is used.
- There is no procedure or execution going on.
- It's a static description of a gate diagram.
- A hardware simulator will validate the diagram.
- Diagrams are read left to right, HDL top to bottom.
- Order of HDL statements is significant.
- Syntax:
  #+begin_example
  Not (in= ,out= );
  And (a=, b=, out= );
  Or (a=, b=, out= );
  #+end_example
- Connections: =partName (a=a, ...);= and =partName(...,out=out);=

Most common HDLs:
- VHDL
- Verilog

Our HDL:
- Similar in spirit to other HDLs
- Minimal and simple
- Provides all you need for learning
- Syntax can be mastered in an hour
- Is accompanied by an online hardware simulator
- There is also a desktop Java application
  
*See also:* Textbook Appendix A, HDL Survival Guide (nand2tetris.org)

* Hardware simulation

- The simulator is written in Java.

- Simulation options:

  1) interactive

  2) script-based

  3) with or without output and compare file

- Simulation process:

  1) Load the HDL file into the hardware simulator

  2) Enter values (0,1) into the chip's input pins

  3) Evaluate the chip's logic

  4) Inspect the resulting values of input/output pins

- This is like LogiSim simulation except non-graphical.

- We will use LogiSim + HDL for our chip project.

* Installing the Hardware Simulator locally

- Follow the instructions here for Windows/MacOS/Linux:
  [[https://tinyurl.com/hdl-install][tinyurl.com/hdl-install]] - download and unzip the code.

- To open the simulator like a regular executable, you can create a
  symbolic link in any directory, on Linux e.g. in =~/.local/bin=:
  #+begin_example sh
  ln -s ~/nand2tetris/tools/HardwareSimulator.sh HardwareSimulator
  #+end_example

- Make the file executable so that you can run it
  #+begin_example sh
  chmod +x HardwareSimulator
  #+end_example

- Check that it's in the ~$PATH~:
  #+begin_example
  which HardwareSimulator
  #+end_example

- Since this is a Java application, you may need to change the app
  resolution. Insert =-Dsun.java2d.uiScale=2= between the =java= and the
  =-classpath= option in the .sh file:
  #+begin_example sh
  java -Dsun.java2d.uiScale=2 \  ### <-- Added scaling property here
		-classpath ...
  #+end_example

- The advantage of this simulator is that you can test any chip with
  it, and not just the chips prescribed for the Nand2Tetris project.

* Demo of the IDE - NOT and XOR chips

1) Open the online IDE at [[https://nand2tetris.github.io/web-ide/][nand2tetris.github.io/web-ide/]].

2) You want to simulate the following gate:
   [[../img/XOR_gate.png]]

3) Select ~HDL Builtin~ at the top: Here you can try the simulation
   without specifying the implementation (it's already done).

4) Middle pane: Change input from 0 to 1 & run the values with ~Eval~.

5) Go to the last pane, ~reset~ the script at the top then ~step~
   through it. After the first step, open the ~Output File~ to see the
   output. The ~Compare File~ contains the sample output that must be
   met.

6) Now disable ~HDL - Builtin~. The HDL file changes: The code below
   the ~PARTS~ keyword is missing. This is the *stub file*.

7) Use the following diagram to derive the ~PARTS~ description:
   #+attr_html: :width 600px :float nil:
   #+caption: XOR gate diagram
   [[../img/XOR_gate_diagram.png]]

8) Each line follows the template:
   #+begin_example
   [Gate] (in=[input], out=[output]);
   #+end_example

9) Since there are five gates, you need five instructions. They need
   to be unique. Add this code to the
   #+begin_example C
     Not (in=a, out=nota); // lower NOT
     Not (in=b, out=notb); // upper NOT
     And (a=a, b=notb, out=w1); // upper AND
     And (a=nota, b=b, out=w2); // lower AND
     Or  (a=w1, b=w2, out=out);
   #+end_example

10) Change the pins in the middle pane to get the desired
    results. Run the ~Test Script~ already prepared and compare the
    ~Output File~ with the ~Compare File~.

11) Your browser will save the IDE configuration but you should
    download the HDL files as ZIP files. You can also load .hdl
    files or copy/paste them from an editor.

* Testing

- Here is the =Xor.tst= file:
  #+begin_example C
  // File name: projects/1/Xor.tst

  load Xor.hdl,        // load HDL script
  compare-to Xor.cmp,  // Xor.cmp is the expected truth table
  output-list a b out; // this generates a truth table

  set a 0,             // a = 0
  set b 0,             // b = 0
  eval,                // run the script for these a,b values
  output;              // write the output-file

  set a 0,  set b 1,  eval,  output;
  set a 1,  set b 0,  eval,  output;
  set a 1,  set b 1,  eval,  output;
  #+end_example

- Real composite chips like an ALU are too complex to just look at a
  chip interactively, and you need complete test & compare files.

- How are compare files .cmp generated?
  #+begin_quote
  By *behavioral simulation* using any implementation that is correct -
  using for example C++ code to create a truth table. In this way you
  can test your hardware before implementing the gate.
  #+end_quote

* Hardware construction projects

- The workflow:
  1) The system architect decides which chips are needed for a
     specific behavior,
  2) and how to break it down into individual chips.
  3) For each chip, the architect creates a chip API (name of the
     chip, names of input and output pins), a test script, a compare
     file.
  4) Developers can now build the chip using HDL.

- The Hack computer e.g. was split into 30+ chipsets by the
  Nand2Tetris designers, and you have to develop the chips.

- Every chip in the IDE comes with:
  1) A .hdl stub file (the chip interface)
  2) A compare file (what the chip is supposed to do)
  3) A test file (how to test the chip)

- Missing: Chip implementation.

* Simulator demo (Canvas in-class assignment) with Nand

- I am demonstrating the use of the simulator using a simulation of
  the Nand chip (which is a primitive of HDL):
  #+attr_html: :width 400px :float nil:
  #+caption: The NAND gate implementation (LogiSim)
  [[../img/NAND.png]]

- We will learn to create this type of diagram in the LogiSim
  application, too, because it is useful to visualize the gates, and
  also because you can simulate individual settings.

- These are the steps to developing and testing a chip in HDL:
  1. Model the gate in LogiSim Evolution.
  2. Extract the compare file from LogiSim Evolution.
  3. Write HDL file in an editor.
  4. Open the HDL simulator software.
  5. Load HDL file into the simulator.
  6. Run HDL file in the simulator.
  7. Write test script in an editor.
  8. Load test script into the simulator.
  9. Load the compare file into the simulator.
  10. Run test script against the compare file.

- The process in detail using =Nand.hdl=, =Nand.tst= and =Nand.cmp=:
  1) Write HDL description for the chip (=.hdl=). A description includes
     a header with the API (Boolean logic), and a ~CHIP~ structure with
     two parts: The user interface (~IN~ and ~OUT~ pins), and the
     implementation in the form of ~PARTS~.

     Here is =Nand.hdl=:
     #+begin_src txt :tangle ~/nand2tetris/projects/mb/Nand.hdl
       // File name: Nand.hdl
       //
       //  Nand gate API:
       //  if ((a==1) and (b==1) then out = 0 else out = 1
       //
       CHIP Nand {  // chip name
         IN a,b;    // input pins
         OUT out;   // output pin

        PARTS:
         And(a=a, b=b, out=aAndb);
         Not(in=aAndb, out=out);
       }
     #+end_src

     Because the chip has two serial primitives, =And= and =Not=, the
     =PARTS= implementation has two lines:

     - In the next figure, I have indicated the =IN= and =OUT= pins and
       the wire names for the HDL chip description:
       #+attr_html: :width 400px :float nil:
       #+caption: Nand gate with HDL descriptors (LogiSim)
       [[../img/NAND_hdl.png]]

     - =And(a=a, b=b, out=aAndb)= means that =a= and =b= are fed to an =And=
       gate whose output wire is called =aAndb=. Any name would be OK
       here, for example =tmp=.

     - =Not(in=aAndb, out=out)= means that the =Not= gate gets its input
       from the =aAndb= wire and has =out= as its output.

  2) Load the =.hdl= file into the simulator (=File - Load Chip=). Fix
     syntax issues and run it on one or more test cases manually.
     #+attr_html: :width 400px :float nil:
     [[../img/nand_load_hdl.png]]

  3) Write a testing script (=.tst=) that loads the chip file, the file
     that the test checks for correctness, and a series of settings
     for the pins. These settings are evaluated and written into an
     output file.

     The testing script assumes that =Nand.hdl= and =Nand.cmp= are in the
     same directory as =Nand.tst=. It's pretty clear what it does:
     - =load= loads the =.hdl= file.
     - =output-file= specifies the output file.
     - =compare-to= specifies the compare file
     - =output-list= specifies the output file header
     - Each setting of pins has its own statement whose commands are
       separated by comma:
       #+begin_example C
       set a 0,     // set pin `a` to value `0`
       set b 0,     // set pin `b` to value `0`
       eval,        // evaluate the loaded file with these values
       output;      // write the output to the output-file
       #+end_example

     Here is the complete script:
     #+begin_src txt :tangle ~/nand2tetris/projects/mb/Nand.tst
       load Nand.hdl,
       output-file Nand.out,
       compare-to Nand.cmp,
       output-list a b out;

       set a 0, set b 0, eval, output;
       set a 0, set b 1, eval, output;
       set a 1, set b 0, eval, output;
       set a 1, set b 1, eval, output;
     #+end_src

  4) Once the script is loaded (=File - Load Script=), you can run it
     step by step orr in one go using the arrow buttons at the top or
     the =Run= menu. The script line currently being worked at is
     highlighed in yellow. Messages appear at the bottom.
     #+attr_html: :width 600px :float nil:
     [[../img/Nand_success.png]]

  5) The =output-file= is automatically compared with the
     =compare-file=. Both of these contain the state space of the gate
     in the form of a truth table.

     The first line entries come from the =output-list= of the testing
     script.
     #+begin_src txt :tangle ~/nand2tetris/projects/mb/Nand.cmp
     | a | b |out|
     | 0 | 0 | 1 |
     | 0 | 1 | 1 |
     | 1 | 0 | 1 |
     | 1 | 1 | 0 |
     #+end_src

  6) Once the tests pass, compress the =.hdl=, the =.tst= and the =.cmp=
     file with zip, and submit the =.zip= file.
     #+begin_src bash :results output :exports both
       cd ~/nand2tetris/projects/mb
       zip -v Nand.zip Nand.hdl Nand.tst Nand.cmp
       file Nand.zip
     #+end_src

     #+RESULTS:
     : updating: Nand.hdl       (in=245) (out=168) (deflated 31%)
     : updating: Nand.tst       (in=221) (out=99) (deflated 55%)
     : updating: Nand.cmp       (in=70) (out=35) (deflated 50%)
     : total bytes=536, compressed=302 -> 44% savings
     : Nand.zip: Zip archive data, at least v2.0 to extract, compression method=deflate

* Multi-Bit Buses

- To carry out operations, we usually manipulate collections of bits
  in the form of arrays.

- Conceptually, it is convenient to think about such a collection as a
  single entity called a "bus".

- Hardware description languages provide convenient notation for
  handling bus data.

- Example: Addition of two 16-bit integers
  #+attr_html: :width 400px :float nil:
  [[../img/16_bit_adder.png]]

- Both ~a~ and ~b~ input carry 16 bits each, so there are 32 wires going
  in and 16 wires for 16 bits output ~out~ coming out of the chip.

- Nevertheless, it is easier to think of two numbers going in and one
  number coming out.

- In HDL, the interface would look like this:
  #+begin_src C
    // Adds two 16-bit values
    CHIP Add16 {
      IN a[16], b[16];
      OUT out[16];

     PARTS:
      // ...
    }
  #+end_src

- This approach generalizes to more numbers (aka arrays): for example,
  for the addition of three 16-bit values, we can add ~first~ and
  ~second~, and then add the result to ~third~. For the implementation, we
  use two ~Add16~ chips and store the intermediate result in an array
  ~temp~:
  #+begin_src C
    // Adds two 16-bit values
    CHIP Add3Way16 {
      IN first[16], second[16], third[16];
      OUT out[16];

     PARTS:
      Add16(a=first, b=second, out=temp); // store temporary result
      Add16(a-temp,  b=third,  out=out);
    }
  #+end_src

- How about a chip that has a bus of 4 bits as input and as output the
  single bit that's in the bus? To do that, we need to add (with AND)
  all bits, two at a time (since out basic gates only have 2 inputs):

  #+begin_src C
    // ANDs together all 4 bits of the bus input
    CHIP And4Way {
      IN a[4];
      OUT out;

     PARTS:
      AND(a=a[0], b=a[1], out=t01);
      AND(a=t01,  b=a[2], out=t02);
      AND(a=t02,  b=a[3], out=out);
    }
  #+end_src

- Multi-way chips do this: Mash values from different buses into one
  another.

- How would you XOR the first and last bits of a 16-bit bus named =bus=?
  - [X] XOR(a=bus[0], b=bus[15], out=out);
  - [ ] XOR(a=bus[0], b=bus[16], out=out);
  - [ ] XOR(a=bus[1], b=bus[15], out=out);
  - [ ] XOR(a=bus[1], b=bus[16], out=out);

- Example of bit-wise AND of parallel arrays or buses:
  #+begin_src C
    // Computes bit-wise AND of its two 4-bit input buses.
    CHIP And4 {
      IN a[4], b[4];  // parallel arrays
      OUT out[4];     // their bit-wise AND

     PARTS:
      AND(a=a[0], b=b[0], out=out[0]);
      AND(a=a[1], b=b[1], out=out[1]);
      AND(a=a[2], b=b[2], out=out[2]);
      AND(a=a[3], b=b[3], out=out[3]);
    }
  #+end_src

- Buses can be composed from and broken into sub-buses.

- Example: The CHIP input is two 8-bit buses (least and most
  significant byte) - here input and output composition is shown:
  #+begin_src C
    ...
    IN lsb[8], msb[8],...
      ...
      // 16-bit input composed from two 8-bit sub-buses
      Add16(a[0..7]=lsb, a[8..15]=msb, b=..., out=...);
      // 16-bit output composed from one 4-bit and one 12-bit sub-bus)
      Add16(..., out[0..3]=t1, out[4..15]=t2);
  #+end_src

- Some syntactic choices of Nand2Tetris' HDL:
  1) Overlaps of sub-buses are allowed on output buses of parts.
  2) Width of internal pins is deduced automatically.
  3) ~false~ and ~true~ may be used as buses of any width.

- Given the interface description
  #+begin_example C
  OUT out, out2[16];
  #+end_example
  Which of the following lines are valid in HDL when implementing the
  =Example16= chip?
  - [ ] Add16(a=Bus1[0..15], b=Bus2[0..15], out=out2[0..14]);
  - [X] Add16(a=Bus1[0..15], b=Bus2[0..15], out[0..14]=out2[0..14]);
  - [X] Add16(a=true, b=false, out=out2);
  - [ ] Add16(a=c, b=Bus2[0..15], out=out2);
  - [X] And(a=c, b=Bus2[7], out=out);

- Explanation:
  #+begin_quote
  1) =Add16(a=true, b=false, out=out2);= is correct because ~true~ and
     ~false~ can represent a bus with constant signal of any width.
  2) =Add16(a=Bus1[0..15], b=Bus2[0..15], out[0..14]=out2[0..14]);= is
     correct becuase =out[0..14]=out2[0..14]= means that we are
     discarding the most significant (15th) bit of =Add16='s ~out~ and
     using the rest to connect to the 15 least significant bits of
     =Example16='s ~out~.
  3) =And(a=c, b=Bus2[7], out=out);= is correct because ~And~ expects
     single bits as inputs ~a~ and ~b~.
  #+end_quote

* 16-bit variants

- Each input of the And16 gate is a 16-bit vector. In LogiSim, you
  need to change the number of =Data Bits= to 16 for input, output and
  for the And gate.

- In the image, a[0] \land b[0] = 1.1 = 1.
  #+attr_html: :width 400px :float nil:
  [[../img/And16.png]]

- *Interesting:* The Analysis Circuit function in LogiSim Evolution
  cannot handle more than 20 inputs, so 8-bit systems is the maximum
  to generate automatic truth tables and/or create circuits from them.

- The computations are not sequential but parallel - all operations
  are 2-to-1 bit. The gate is a 16-bit extension of the elementary And
  gate. In the HDL file you have =IN a[16],b[16]=, =OUT out[16]=, and 16
  elementary gates:
  #+begin_example txt
  AND(a=a[0], b=b[0], out=out[0])
  AND(a=a[1], b=b[1], out=out[1])
  ...
  #+end_example

* Multiplexer (Mux)

- A *multiplexer* selects binary information from one of many input
  lines and directs it to a single output line. The selection of a
  particular line is controlled by a set of selection lines. Normally,
  there are 2^n input lines and n selector lines.

- =Mux= is a 2-way multiplexer with 2 input lines and 1 selector line.
  #+attr_html: :width 200px :float nil:
  [[../img/mux.png]]

- To get the complete truth table, let's write a C++ program: It runs
  through the values [0,1] for three input variables a,b,sel, with the
  API: =if (sel==0) then out=a; else out=b=

  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    cout << "| a | b | sel | out |\n"
    << "---------------------\n";
    for (bool sel : {false,true})
      {
        for (bool a : {false,true})
          {
            for (bool b : {false,true})
              {
                if (!sel)
                  cout <<"| "<<a<<" | "<<b<<" |  "<<sel<<"  |  "<<a<<"  |\n";
                else
                  cout <<"| "<<a<<" | "<<b<<" |  "<<sel<<"  |  "<<b<<"  |\n";
              }
          }
      }
  #+end_src

  #+RESULTS:
  #+begin_example
  | a | b | sel | out |
  ---------------------
  | 0 | 0 |  0  |  0  |
  | 0 | 1 |  0  |  0  |
  | 1 | 0 |  0  |  1  |
  | 1 | 1 |  0  |  1  |
  | 0 | 0 |  1  |  0  |
  | 0 | 1 |  1  |  1  |
  | 1 | 0 |  1  |  0  |
  | 1 | 1 |  1  |  1  |
  #+end_example

- In this case, an abbreviated truth table will do:
  | sel | out |
  |-----+-----|
  |   0 | a   |
  |   1 | b   |

- MUX is used to build a programmable gate: You can select either an
  AND or an OR gate:
  #+begin_example
  if (sel==0)
    out = (a And b)
  else
    out = (a Or b)
  #+end_example

- Truth table:
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    cout << "| a | b |sel|out|\n";
    for (bool sel : {false,true})
      {
        for (bool a : {false,true})
          {
        for (bool b : {false,true})
          {
            if (!sel)
              cout <<"| "<<a<<" | "<<b<<" | "<<sel<<" | "
                   << (a&&b) <<" |\n";
            else
              cout <<"| "<<a<<" | "<<b<<" | "<<sel<<" | "
                   << (a||b) <<" |\n";
          }
          }
      }
  #+end_src

  #+RESULTS:
  : | a | b |sel|out|
  : | 0 | 0 | 0 | 0 |
  : | 0 | 1 | 0 | 0 |
  : | 1 | 0 | 0 | 0 |
  : | 1 | 1 | 0 | 1 |
  : | 0 | 0 | 1 | 0 |
  : | 0 | 1 | 1 | 1 |
  : | 1 | 0 | 1 | 1 |
  : | 1 | 1 | 1 | 1 |

- Or shorter:
  | sel | out     |
  |-----+---------|
  |   0 | a And b |
  |   1 | b Or b  |

- To get the circuit diagram, import the truth table in this text
  format (for Mux):
  #+begin_example
  a b c | x
  ~~~~~~~~~
  0 0 0 | 0
  0 0 1 | 0
  0 1 0 | 0
  0 1 1 | 1
  1 0 0 | 1
  1 0 1 | 0
  1 1 0 | 1
  1 1 1 | 1
  #+end_example

- Modifying the code accordingly:
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    cout << "a b c | x \n";
    cout << "~~~~~~~~~\n";
    for (bool sel : {false,true})
      {
        for (bool a : {false,true})
          {
        for (bool b : {false,true})
          {
            if (!sel)
              cout <<a<<" "<<b<<" "<<sel<<" | " << (a && b) << endl;
            else
              cout <<a<<" "<<b<<" "<<sel<<" | " << (a || b) << endl;
          }
          }
      }
  #+end_src

  #+RESULTS:
  #+begin_example
  a b c | x
  ~~~~~~~~~
  0 0 0 | 0
  0 1 0 | 0
  1 0 0 | 0
  1 1 0 | 1
  0 0 1 | 0
  0 1 1 | 1
  1 0 1 | 1
  1 1 1 | 1
  #+end_example

- The result is not very clear and far from the presented minimal
  diagram because the multiplexer was re-built instead of used.
  #+attr_html: :width 400px :float nil:
  [[../img/AndMuxOr_LogiSim.png]]

- This diagram does the job: It shows how the a,b input is fanned out
  into both And and Or gates, and the Mux decides the output.
  #+attr_html: :width 400px :float nil:
  [[../img/AndMuxOr.png]]

- The HDL code for this Chip:
  #+begin_src txt :tangle ../hdl/project1/AndMuxOr.hdl
    CHIP AndMuxOr {
      IN a, b, sel;
      OUT out;

      PARTS:
      And(a=a,b=b,out=andOut);
      Or (a=a,b=b,out=orOut);
      Mux(a=andOut,b=orOut,sel=sel,out=out);
    }
  #+end_src

- The testing script:
  #+begin_src txt :tangle ../hdl/project1/AndMuxOr.tst
    load AndMuxOr.hdl,
    output-file AndMuxOr.out,
    compare-to AndMuxOr.cmp,
    output-list a b sel out;

    set a 0, set b 0, set sel 0, eval, output;
    set a 0, set b 1, set sel 0, eval, output;
    set a 1, set b 0, set sel 0, eval, output;
    set a 1, set b 1, set sel 0, eval, output;
    set a 0, set b 0, set sel 1, eval, output;
    set a 0, set b 1, set sel 1, eval, output;
    set a 1, set b 0, set sel 1, eval, output;
    set a 1, set b 1, set sel 1, eval, output;
  #+end_src

- The compare file from code:
  #+begin_src txt :tangle ../hdl/project1/AndMuxOr.cmp
  | a | b |sel|out|
  | 0 | 0 | 0 | 0 |
  | 0 | 1 | 0 | 0 |
  | 1 | 0 | 0 | 0 |
  | 1 | 1 | 0 | 1 |
  | 0 | 0 | 1 | 0 |
  | 0 | 1 | 1 | 1 |
  | 1 | 0 | 1 | 1 |
  | 1 | 1 | 1 | 1 |
  #+end_src

- Implementing Mux from elementary gates: This can be done with And,
  Or, and Not gates. So the normal form method applies:
  #+begin_example
  | a | b |sel|out|
  | 0 | 0 | 0 | 0 |
  | 0 | 1 | 0 | 0 |
  | 1 | 0 | 0 | 0 |
  | 1 | 1 | 0 | 1 |
  | 0 | 0 | 1 | 0 |
  | 0 | 1 | 1 | 1 |
  | 1 | 0 | 1 | 1 |
  | 1 | 1 | 1 | 1 |
  #+end_example

* Demultiplexer (DMux)

- Inverted 2-way multiplexer: Depending on the selection bit, it
  channels or distributes the input to either the a or the b output.
  #+attr_html: :width 300px :float nil:
  [[../img/DMux.png]]

- The API:
  #+begin_example
  if (sel==0)
     {a,b}={in,0}
  else
     {a,b}={0,in}
  #+end_example

- The truth table from the diagram (reuse code, change function):
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    cout << "|in |sel| a | b |\n";
    for (bool in : {false,true})
      {
        for (bool sel : {false,true})
          {
        if (!sel)
          cout <<"| "<<in<<" | "<<sel<<" | " << in << " | " << 0 << " |\n";
        else
          cout <<"| "<<in<<" | "<<sel<<" | " << 0 << " | " << in << " |\n";
          }
      }
  #+end_src

  #+RESULTS:
  : |in |sel| a | b |
  : | 0 | 0 | 0 | 0 |
  : | 0 | 1 | 0 | 0 |
  : | 1 | 0 | 1 | 0 |
  : | 1 | 1 | 0 | 1 |

- *Review question:* Suppose that 1 is fed into the IN input of a DMux
  chip, and the output wires are fed into a Mux chip. What would be
  the output of the Mux?

  - [ ] 0

  - [ ] 1

  - [ ] It depends on the selection bits of the chips.

- *Review question:* Suppose that 1 is fed into the IN input of a DMux
  chip, the output wires are fed into a Mux chip, the selection bits
  of the Mux and of the DMux are set to 0 - what's the output of the
  Mux?
  #+begin_quote
  if (sel_{DMux}==0) then {a,b}_{DMux} = {in,0} = {1,0}
  if (sel_{Mux}==0) then out_{Mux} = b = 1.
  #+end_quote

- *Example:* Multiplexing and demultiplexing in communication networks
  without synchronizing source or destination. Multiple data streams
  can be combined into one shared transmission medium so that more
  than one signal can travel on the same channel. An oscillator
  produces selection bits that select one or the other stream.

- *Mux:* Several devices in your home share the same 2.4 GHz radio band,
  and when you have a fiber optic connection, many customer signals
  are travelling on the same fiber independently.

- *DMux:* The Wifi access point separates the signals based on timing,
  channel frequency, or MAC addresses (broadcast).

* Multi-way variants
#+attr_html: :width 400px :float nil:
[[../img/Mux4Way16.png]]

- You have a 2-bit selector because you need 2 bits to select 4
  different possibilities - one selector for {a,b} and one for {c,d}.

- The abbreviated truth table:

  | sel[1] | sel[0] | out |
  |--------+--------+-----|
  |      0 |      0 |  a  |
  |      0 |      1 |  b  |
  |      1 |      0 |  c  |
  |      1 |      1 |  d  |

- The HDL stub:
  #+begin_src txt
    CHIP Mux4Way16 {
      IN a[16],b[16],c[16],d[16],sel[2];
      OUT out[16];

    PARTS:
    // ...
    }
  #+end_src

- The chip can be built from several Mux16 gates and other elementary
  gates as needed.



* Project 1 Overview ([[https://youtu.be/OZlvyGaRmQQ?si=XPpL1u-SwUJV0VfS][video]])
** Overview

#+attr_html: :width 400px :float nil:
[[../img/michelangelo.png]]

- Why these gates?
  #+begin_quote
  They are commonly used, and they are all the elementary 2-bit logic
  gates, 16-bit and multi-way variants needed to build our computer.
  #+end_quote

- Overview:
  | Elementary | 16-bit variant | Multi-way variant |
  |------------+----------------+-------------------|
  | Not        | Not16          | Or8Way            |
  | And        | And16          | Mux4Way16         |
  | Or         | Or16           | Mux8Way16         |
  | Xor        | Mux16          | DMux4Way          |
  | Mux        |                | DMux8Way          |
  | DMux       |                |                   |

** How to proceed

- Once you built NOT, AND etc. in NAND form, you can use them.

- Xor as an example. You get an API, a .cmp compare file, a testing
  script .tst, a .hdl stub. You have built then chip if when running
  your Xor.hdl on the supplied Xor.tst, your Xor.out is the same as
  the supplied Xor.cmp.

- All the files are included in the local software and in the online
  IDE (which can be reset).

** Hack Chipset API

- How can you know what the names of the input and output pins are?
  #+begin_quote
  If the gates are part of the Hack software set then the API is
  included in the HDL survival guide.
  #+end_quote

- If you don't implement some chips from the Hack chipset, you can
  still use them as chip-parts of other chips, just rename their given
  stub files (You cannot do this in the Online IDE, I think).

- When the simulator gets to the part in the implementation and cannot
  find a part, it will automatically revert to the built-in chip. So
  you can build the chips in any order in principle.

- Best practice advice:

  1) Build the chips in the given order (complexity ordered).

  2) You can use built-in implementations.

  3) You could design "helper chips" that are like "private methods"
     but you don't really need or should do it.

  4) Stive to use as few chip parts as possible (elegant, readable,
     well designed).

- Implementation endnotes

  1) You have to use an external editor (outside of the online IDE).

  2) A chip cannot be used in its own implementation - there's no
     recursion.

  3) In the simulator, errors are reported in red at the bottom left.

  4) Multi-bit busses are indexed right to left: if A is a 16-bit bus
     then A[0] is the right-most bit (aka Least Significant Bit or
     LSB), and A[15] is the left-most bit (aka Most Significant Bit or
     MSB).

* Perspectives & Followup questions

1) Is it possible to build a computer with a logic gate other than NAND?
   #+begin_quote
   You can also use NOR, or {And, Or, Not} gates, or other
   possibilities. These are like axioms in geometry. NAND are popular
   because they are cheap to build.
   #+end_quote
2) If you actually had to build a NAND gate, how would you do it?
   #+begin_quote
   That's rather physics than Computer Science: An NMOS or CMOS
   2-transistor implementation that establishes the logic at the
   physical level. But for Hack we abstract the physics away.
   #+end_quote
3) How does this HDL compare to real HDLs in the professional field?
   #+begin_quote
   This HDL is pretty real but other HDLs have a lot more high level
   programming constructs similar to C. They feature the notion of
   time and clocks to build sequential logic (for memories/counters).
   #+end_quote
4) The chips of project 1 are simple. How do you go about designing
   complex chips with hundreds of parts and connections?
   #+begin_quote
   There are many different techniques, like Karnaugh maps, to
   simplify Boolean functions. At the same time, many chip design
   sub-problems are NP-complete or NP-hard involving: Placement,
   timing optimization, power optimization, routing etc. Therefore,
   solution approaches are not exact but heuristic, supported by
   approximation algorithms: You break the problem down into simpler
   ones, which are easier to optimize and construct.
   #+end_quote
