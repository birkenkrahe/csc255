#+TITLE: Session on Boolean Arithmetic (Chapter 2)
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: CSC 255 Computer Architecture - Fall 2025
#+STARTUP: overview hideblocks indent
#+OPTIONS: toc:1 num:1 ^:nil
#+PROPERTY: header-args:R :session *R* :results output :exports both :noweb yes
#+PROPERTY: header-args:python :session *Python* :results output :exports both :noweb yes
#+PROPERTY: header-args:C :main yes :includes <stdio.h> :results output :exports both :noweb yes
#+PROPERTY: header-args:C++ :main yes :includes <iostream> :results output :exports both :noweb yes
* Objectives
- Grasp binary number representation and its constraints.
- Master binary addition with carry propagation and overflow detection.
- Understand negative number representation using two's complement.
- Explore the ALU specification for the Hack computer.

Sources: Nand2Tetris by Nisan/Schocken (MIT Press, 2020), and Grok.

* Introduction

** Hook

- Quote: "Counting is the religion of this generation, its hope and
  salvation." (Gertrude Stein, 1874–1946) What does she mean by that?
  #+begin_quote
  The quote metaphorically highlights the central role of numerical
  systems, particularly binary, in modern computing. What does
  "religion" promise? - Salvation through technological progress and
  abstraction. Which abstraction is involved in counting?

  The abstraction that everything can be counted.
  #+end_quote

- Prompt: "Why might binary be critical for computers?"
  #+begin_quote
  Binary is fundamental to computers for several compelling
  reasons. First, it aligns perfectly with the physical nature of
  *electronic circuits*, which operate using two distinct states—on
  (representing 1) and off (representing 0). This two-state system is
  inherently reliable because it minimizes ambiguity; unlike decimal
  systems with ten states (0-9), which could require precise voltage
  levels for each digit, binary only needs to distinguish between two
  levels, *reducing error rates* in hardware.

  Second, binary simplifies the design and *manufacturing of digital
  components* like transistors and gates. These components can be built
  using basic switches that are either open or closed, making
  production cost-effective and scalable—crucial for mass-producing
  computers.

  Third, binary supports *efficient computation* through Boolean
  algebra: where logical operations (AND, OR, NOT) map directly to
  circuit behavior, enabling complex calculations to be broken down
  into manageable steps.

  Finally, binary’s *fixed-width representation* (e.g., 16-bit words)
  allows computers to handle data uniformly, facilitating memory
  addressing and arithmetic operations, which are the backbone of
  programming.

  This synergy between hardware simplicity and computational power is
  why binary became the universal language of computing.
  #+end_quote

** Agenda

- Detailed lecture on Binary Numbers, Binary Addition, Two's
  Complement, and ALU Specification (35 minutes).

- Brief Practice and Wrap-up (10 minutes).

- Note: Hardware implementation (e.g., adders, ALU) is for the next
  session.

- Today, we’ll build a theoretical foundation for how computers
  handle numbers and computations. Let’s start with binary.

* Binary Numbers

** Concept

- When we are told that a certain code, say, 6083, represents a number
  using the decimal system, then, by convention, we take this number
  to be decomposable into a sum of powers of 10: Each digit is \(d \times
  10^p\) (e.g., 6×10² + 0×10¹ + 8×10⁰). 10 is the base of this system.

- Binary uses base-2: Similarly, the code 10011 represents a number
  using base 2, where each bit is \(b \times 2^p\).

- Fixed-width words: Computers are finite machines that use a fixed
  word size for representing numbers. The fixed word size implies that
  there is a limit on the number of values that these registers can
  represent" E.g., 16-bit Hack range is 0 to 65,535 (\(2^{16}\)).

- Maximum value: With \(k\) bits all 1, the range is 0 to \(2^k -
  1\). Proof: \(2^0 + 2^1 + \cdots + 2^{k-1} = 2^k - 1\) - Geometric series
  sum:
  #+begin_quote
  \(S = a\frac{r^n-1}{r-1}\)
  #+end_quote
  Where $a$ is the first value, and $r$ is the base value (2).

- The decimal representation of numbers is a human indulgence:
  Computers handle everything in binary and care naught about decimal.

- Large numbers require multiple registers, impacting speed.
  #+begin_quote
  Each register holds a portion of the number, e.g. high and low
  bits. This is called *multi-precision arithmetic*. This process
  involves carry propagation between registers, which increases
  latency and slows down processing.
  #+end_quote

** Example
- Convert 45 to 8-bit binary: 32 (2⁵) + 8 (2³) + 4 (2²) + 1 (2⁰)
  = 00101101. Verify: \(0×2^7 + 0×2^6 + 1×2^5 + 0×2^4 + 1×2^3 +
  1×2^2 + 0×2^1 + 1×2^0 = 32 + 8 + 4 + 1 = 45\).

- Do it yourself: Convert 87 (dec) into binary!
  #+begin_example
  0d87 = 64 + 16 + 4 + 2 + 1 = 1010111 -> 0b01010111
         ^6   ^4  ^2  ^1  ^0
  #+end_example

- Do it yourself: Convert 99 (dec) into binary!
  #+begin_example
  99 = 64 + 32 + 2 + 1 = 0b01100011
  #+end_example

- Reverse: 1100101 to decimal: \(1×2^6 + 1×2^5 + 0×2^4 + 0×2^3 +
  1×2^2 + 0×2^1 + 1×2^0 = 64 + 32 + 0 + 0 + 4 + 0 + 1 = 101\).

- Max 4-bit: 1111 = \(8 + 4 + 2 + 1 = 15\), or \(2^4 - 1 = 15\).

- Inside computers, everything is represented using binary codes. For
  example, when we press the keyboard keys labeled 1, 9, and
  Enter... what ends up stored in the computer’s memory is the binary
  code 10011. Do you remember from the first part of the class, how?
  #+begin_quote
  Initially, pressing the keys 1, 9, and Enter sends electrical
  signals through the keyboard’s circuitry, which are interpreted by
  the computer’s input system as specific key codes based on standards
  like ASCII (American Standard Code for Information Interchange). The
  key 1 is encoded as 49 in decimal (binary 110001), 9 as 57 (binary
  111001), and Enter as 13 (binary 1101) in ASCII, but the example
  simplifies this to 10011, likely representing a processed or
  truncated value (e.g., a partial input or error in the
  example). These signals are converted into binary data—sequences of
  0s and 1s—by the keyboard controller, which toggles voltage levels
  (e.g., 0V for 0, 5V for 1) in the computer’s hardware. This binary
  data is then stored in the computer’s memory, typically RAM, as a
  series of bits organized into bytes, where 10011 might reflect a
  5-bit segment of a larger word (e.g., padded to 8-bit 00010011 for
  19 in decimal). The operating system and software further process
  this data, mapping it to characters or commands, but at the hardware
  level, it remains a binary representation, enabling the computer to
  manipulate and store information efficiently
  #+end_quote

** Overflow and multi-bit use

- Overflow example: What is 16-bit 65,535 + 1 on a 16-bit computer?
  #+begin_quote
  65,535 + 1 = 0 (wraps around). Max value  11111111 11111111.
  65,536 requires a 17-bit representation (100000000 00000000).

  The result of adding any two n-bit numbers will be correct up to n
  bits.
  #+end_quote

- Multi-bit use: Does entering the number equivalent to \(2^{32}\) cause
  overflow?
  #+begin_quote
  32-bit systems handle 0 to 4,294,967,295 for unsigned integers,
  common in modern CPUs (\(2^{32}-1\)). Overflow occurs when you try to
  add 1 to that number. The transition triggers the overflow.
  #+end_quote

- Why can I then still do this:
  #+begin_src R :session *R* :results output :exports both
    1.844674e+19+1
  #+end_src

  #+RESULTS:
  : [1] 1.844674e+19

- Answer:
  #+begin_quote
  It works because it is handled as a floating-point number or an
  unbounded integer (as in R/Python - more bits are allocated
  dynamically). Must check the exact data type, e.g. ~uint64_t~ in C.
  #+end_quote

** Visual (1 minute)

- Whiteboard: 4-bit table (0000=0 to 1111=15) with overflow arrow.
  #+begin_example
+-----------------------------------+
| Binary | Decimal | Notes          |
+-----------------------------------+
| 0000   | 0       |                |
| 0001   | 1       |                |
| 0010   | 2       |                |
| 0011   | 3       |                |
| 0100   | 4       |                |
| 0101   | 5       |                |
| 0110   | 6       |                |
| 0111   | 7       |                |
| 1000   | 8       |                |
| 1001   | 9       |                |
| 1010   | 10      |                |
| 1011   | 11      |                |
| 1100   | 12      |                |
| 1101   | 13      |                |
| 1110   | 14      |                |
| 1111   | 15      | Max 4-bit      |
+-----------------------------------+
       |          \
       |           \
       v            \
[Overflow Arrow] --> 10000 = 16 (requires 5 bits)
  #+end_example

* Binary operations

- What do we want to do with numbers?
  #+begin_quote
  + Addition
  + Subtraction
  + Multiplication
  + Division
  + Comparison
  #+end_quote

- What we want to avoid:
  #+begin_quote
  "Extra hardware" - special chips that can only do one operation are
  harder to create & run than having one chip that can be manipulated
  with software to perform the ops.

  - The good news: Negative number representation will simplify
    subtraction and comparison without extra hardware.

  - Multiplication and division are deferred to software. As a rule:
    Choose software design over hardware design whenever possible.
  #+end_quote

- We continue with binary addition.

* Binary Addition

- Though we know how to convert decimal to binary that is not what the
  computer does. Instead, it implements a carry-over algorithm.

** Concept - Bitwise addition

- A pair of binary numbers can be added bitwise from right to left,
  using the same decimal addition algorithm. Rules: 0+0=0, 0+1=1,
  1+0=1, 1+1=10 (carry 1).

- Remember that this is different from adding bits logically (rather
  than arithmetically) in a digital circuit, or bitwise AND:
  0 \land 0 = 0 \land 1 = 1 \land 0 = 0 and 1 \land 1 = 1.

- This is second-grade school stuff (when you learnt to add and
  subtract numbers with carry-on):
  #+begin_example
    5 7 8 3
  + 2 4 5 6
  ---------
          9
        3      -> carry 1 (10^2)
      2        -> carry 1 (10^3)
    8
  = 8239
  #+end_example

- We conveniently write binary numbers as 2x4-bit words:
  #+begin_example
    0001 0101 = 21 = 1 + 4 + 16
  + 0101 1100 = 92 = 4 + 8 + 16 + 64
    ---------
            1 = 1 + 0
           0  = 0 + 0
          0   = 1 + 1 = 10     -> 1
         0    = 0 + 1 + 1 = 10 -> 1
       1      = 1 + 1 + 1 = 11 -> 1
      1       = 0 + 0 + 1 = 1
     1        = 0 + 1 = 1

    0111 0001 = 64 + 32 + 16 + 1 = 113
  #+end_example

- Process: Start at LSB, propagate carry to MSB. Continue this
  lockstep process until the two left most significant bits (MSB) are
  added.

- What is the software name for the "carry-on bit"?
  #+begin_quote
  Overflow: If the most significant bitwise addition generates a carry
  of 1, we have what is known as overflow... We are content to
  guarantee that the result of adding any two n-bit numbers will be
  correct up to n bits.
  #+end_quote

- What about overflow?
  #+begin_quote
  If the MSB generates a carry-on bit, the word size is not sufficient
  to hold the result of the addition. The wrap-around replaces the
  carry-on 1 by a 0 and effectively truncates the integer.
  #+end_quote

** Different Adder Designs

- Though we base addition on the simple 2nd grade carry-on algorithm,
  there are actually several different designs:

  + *Ripple-Carry adders (RCA)*: full adders chained together so that
    the carry out of one bit "ripples" to the carry-in of the next.

  + *Carry-Lookahead Adder (CLA)*: precomputes carry signals for all bit
    positions in parallel, reducing computing delay from O(n) to O(log
    n) - critical for high-performance CPUs.

  + *Carry-Skip Adder*: groups bits and skips carry propagation within
    groups when possible using multiplexers to bypass unnecessary
    stages. E.g. if a group of bits has no carry, the carry can skip
    to the next group.

  + *Carry-Select Adder* and *Carry-Save Adder* used in multi-operand
    addition (e.g. multiplication).

** Example

- Compute: 5 + 3 in binary on an 8-bit computer, using carry-on - will
  there be overflow?
  #+begin_example
    0101 5
  + 0011 3
  ------
       0 (1)
      0  (1)
     0   (1)
    1    8   (no overflow)
  #+end_example

- Compute 14 and 1 in binary using carry-on on an 8-bit computer -
  will there be overflow?
  #+begin_example
    1110 14
  + 0001  1
  ------
       1
      1
     1
    1   =15 (no overflow)
  #+end_example

- Compute 15 + 1 on an 8-bit computer using carry-on. Will there be
  overflow?
  #+begin_quote
  1111 (15) + 0001 (1) = 10000 → 0000 (ignore carry,
  incorrect).
  #+end_quote

* Adders

- For the ALU, we distinguish
  + half-adder (designed to add two bits),
  + full-adder (designed to add three bits),
  + adder (designed to add two n-bit numbers)
  + incrementer (designed to add 1 to a given number - but not to add
    at all, only to fetch the next instruction from memory).

** Half Adder

- Going back to the previous example: To do one slice of the whole
  operation, a single carry on in position 2, we don't care about any
  other number anywhere else; we only add 1 + 1 = 10 = 0 carry 1.
  #+begin_example
    0001 0101 = 21 = 1 + 4 + 16
  + 0101 1100 = 92 = 4 + 8 + 16 + 64
    ---------
            1 = 1 + 0
           0  = 0 + 0
          0   = 1 + 1 = 10     -> 1
         0    = 0 + 1 + 1 = 10 -> 1
       1      = 1 + 1 + 1 = 11 -> 1
      1       = 0 + 0 + 1 = 1
     1        = 0 + 1 = 1

    0111 0001 = 64 + 32 + 16 + 1 = 113
  #+end_example

- But that's a 2-input-2-output operation, and we have a CHIP for it,
  the *half adder*:
  #+attr_html: :width 600px :float nil:
  [[../img/half_adder.png]]

- The API:
  #+begin_example C
  CHIP HalfAdder {
    IN a,b;
    OUT sum, carry;
    PARTS:
    // HDL implementation
  }
  #+end_example

- This is the first CHIP to implement in the next lab!

** Full Adder

- The condition for the half adder to work is that the carry-on was
  zero. When it's 1, we have a three-bit addition scenario:
  #+begin_example C
  IN a,b,c;       // c is the carry-on input
  OUT sum, carry; //
  #+end_example

- The CHIP going with this interface is the *full adder*
  #+attr_html: :width 400px :float nil:
  [[../img/full_adder.png]]

- But of course, we know how to handle multi-input-bit and
  multi-output-bit gates.

** Multi-bit Adder

- You can now compose an addition over multiple bits by successive
  full adder operations aka serial chips (this is an RCA or
  ripple-carry adder design).

- Example: For an 8-bit ripple-carry adder, 8 full-adders are chained
  together, where the carry-out of one full-adder serves as the
  carry-in of the next.

- What does this sequential addition (each full-adder waiting for the
  result of the previous one) mean for the time spent on the process?
  #+begin_quote
  Each full-adder performs with O(n) for n bits, for example 8 clock
  cycles for n=8 or an 8-bit addition as in our example.
  #+end_quote

- The serial composition of chips is the multi-bit chip we already
  encountered with And16 and its friends. For a 16-bit Adder, ~out=a+b~
  as 16-bit integers =a[15]=, =b[15]=, =out[16]= (ignoring overflow for
  now).

- Chip interface:
  #+attr_html: :width 400px :float nil:
  [[../img/16_bit_adder.png]]

- Full design:
  #+attr_html: :width 600px :float nil:
  [[../img/16_bit_adder2.png]]

- We're OK to ignore overflow for now (with unsigned integers). But
  for signed integers (negative numbers) we must reconsider.

* IN PROGRESS Building the half adder (with Xor and AND)
#+OPTIONS: toc:nil num:nil ^:nil:  title:nil
- Look at the =output= in the truth table: You notice that the =carry= is
  an =AND= operation, and the =sum= operation is an =Xor= operation.

- You can read the ~CHIP~ implementation straight off the table:
  #+begin_example C
  CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b
        carry;  // Left bit of a + b

    PARTS:
    Xor(a=a,b=b,out=sum);
    And(a=a,b=b,out=carry);
  }
  #+end_example

- Build this in LogiSim! Test it by simulating with
  #+begin_example
  a = 1, b = 1, c = 0 (carry_in) -> carry = 0  (carry_out)
  a = 1, b = 0, c = 1 (carry_in) -> carry = 1  (carry_out)
  a = 1, b = 1, c = 1 (carry_in) -> carry = 0  (carry_out)
  #+end_example

- Solution diagram:
  #+attr_html: :width 400px :float nil:
  [[../img/half_adder_logisim.png]]

- For the project submission, you need to replace the ~XOR~ and the ~AND~
  suitable combination of ~NAND~ chips.

* Building the full adder from half adders

- We begin by building a full adder in Logisim:

  1) Open the software

  2) Under ~Arithmetic~, find the ~Adder~

  3) Change the ~Data Bits~ of the ~Adder~ to =1=

  4) Attach pins for =a=, =b=, and =c= (carry-in)

  5) Label the pins accordingly.

  6) Simulate the operations:
     #+begin_example
     a = 1, b = 0, c_in = 0
     a = 1, b = 1, c_in = 0 -> out = 0, c_out = 1
     a = 1, b = 0, c_in = 1 -> out = 0, c_out = 1
     a = 1, b = 1, c_in = 1 -> out = 1, c_out = 1
     #+end_example

- Solution diagram:
  #+attr_html: :width 400px :float nil:
  [[../img/adder_logisim.png]]

- It would be nice to turn this into a compact chip in LogiSim to
  build the Adder (but I haven't been able to do it).

- For the HDL, we have 1-bit inputs, and a right and a left bit of the
  operation =a + b + c_in= as the API in the IDE shows:
  #+begin_example
  IN a, b, c;  // 1-bit inputs (c is carry-in)
  OUT sum,     // Right bit of a + b + c
      carry;   // Left bit of a + b + c
  #+end_example

- The data flow through the full adder looks like this:
  1) a  +  b    = s1  (first half-adder: intermediate sum)
  2) s1 +  c1   = sum (second half-adder: intermediate sum to carry-in)
  3) c1 OR c2   = carry (carry-out)

  #+begin_example
     a -----\
             HA1 ---- s1 ----\
     b -----/               HA2 ---- sum
                             /
    carryIn  ---------------/

    carryOut = c1 OR c2
  #+end_example

- Build this in the IDE:
  1) first half-adder adds =a + b = s1= and carries =c1=
  2) second half-adder adds =s1 + c = sum= and carries =c2=
  3) Carry-out is OR of the two carries

- Solution:
  #+begin_example C
  CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs (c is carry-in)
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:
    // First half-adder: add a and b
    HalfAdder(a=a , b=b , sum=s1 , carry=c1 );
    // Second half-adder: add intermediate sum to carry-in
    HalfAdder(a=s1 , b=c , sum=sum , carry=c2 );
    // Carry-out is OR of the two carries
    Or(a=c1 , b=c2 , out=carry );
  }
  #+end_example

- For the project submission, you need to replace the ~OR~ with a
  suitable combination of ~NAND~ chips, and you can use the ~HalfAdder~
  (itself built from ~NAND~ only).

* Building the multi-bit adder from half-adder and full-adder

- Here is the API for an ~Add3~ chip:
  #+begin_example C
  CHIP Add3 {
    IN a[3], b[3];
    OUT out[3];
    PARTS:
    // ...
  }
  #+end_example

- Let's use the example of a 3-bit adder ~Add3~ (instead of ~Add16~):
  #+begin_example
   A = 101 (5)            1 0 1
   B = 011 (3)        +   0 1 1
                      ---------
   a[0]+b[0]   LSB            0   1+1=0   out[0] (half-adder) carry = 1
   a[1]+b[1]   Bit 1        0     0+1+1=0 out[1] (full-adder) carry = 1
   a[2]+b[2]   MSB        1       1+0+1=0 out[2] (full-adder) carry = 1
                      = 1 0 0 0
  #+end_example

- From the example, can you design the CHIP?

- Solution:
  #+begin_example C
  // Notice that the carry for the MSB is ignored (overflow)
  HalfAdder(a=a[0], b=b[0], sum=out[0], carry=carry0); // LSB
  FullAdder(a=a[1], b=b[1], c=carry0, sum=out[1], carry=carry1); // Bit 1
  FullAdder(a=a[2], b=b[2], c=carry1, sum=out[2], carry=carry); // MSB
  #+end_example

- You can now generalize this to ~Add16~ easily and test it in the IDE.

* Negative Numbers and Two's Complement

** Concept

- An n-bit binary system can code \(2^n\) different things. If we
  have to represent signed numbers... split the available code
  space into two subsets" (p. 3). Need for negatives.

- Two's complement: "-x is taken to be the code that represents
  \(2^n - x\)" (p. 4), or flip all bits of x and add 1. Range:
  \(-2^{n-1}\) to \(2^{n-1} - 1\).

- "Subtraction is handled as a special case of addition" (p. 4),
  simplifying hardware.

** Example
- 4-bit: 5 = 0101, -5: invert 0101 = 1010, +1 = 1011.
- Add 5 + (-5): 0101 + 1011 = 10000 → 0000 (0, correct).
- Subtract 3 - 5: 3 = 0011, -5 = 1011, 0011 + 1011 = 1110 (-2).
** Additional Insight
- Overflow detection: Sign bit mismatch (e.g., -8 + -1).
- Two's Complement is of the most remarkable and unsung heroes of
  applied computer science
** Visual

- Whiteboard: 4-bit table (0000=0, 1000=-8, 1111=-1).

* ALU Specification
** Concept
- "All the functions performed by digital computers—not only
  arithmetic operations—can be reduced to adding binary numbers"
  (p. 2).
- ALU is the CPU’s computational core, handling addition, sign
  conversion, etc.
- Hack ALU: 16-bit inputs x, y; 6 control bits (zx, zy, nx, ny, f,
  no); outputs: 16-bit result, zr, ng.
** Example
- x + y: f=1, zx=0, zy=0, nx=0, ny=0, no=0 → result = x + y.
- -x: zx=1, nx=1, f=1, no=1 → result = -x.
- Zero flag: zr=1 if result=000...0.
** Additional Insight
- Control bits enable multiplexing (e.g., add vs. AND).
- Precursor to CPU execution.

* Practice
** Exercises 1: Binary Conversion
- Convert 73 to 8-bit binary.
  - Solution: 64 (2⁶) + 8 (2³) + 1 (2⁰) = 01001001.
- Convert 1100100 to decimal.
  - Solution: \(1×2^6 + 1×2^5 + 0×2^4 + 0×2^3 + 1×2^2 + 0×2^1 + 0×2^0 = 64 + 32 + 4 = 100\).
** Exercise 2: Binary Addition
- Add 0110 (6) + 0011 (3).
  - Solution: 0110 + 0011 = 1001 (9).
- Check overflow: 1111 (15) + 0001 (1).
  - Solution: 1111 + 0001 = 10000 → 0000 (overflow).
** Exercise 3: Two's Complement
- Find -3 in 4-bit two's complement.
  - Solution: 3 = 0011, invert = 1100, +1 = 1101.
- Add 2 + (-3).
  - Solution: 2 = 0010, -3 = 1101, 0010 + 1101 = 1111 (-1).
** Exercise 4: ALU Operation
- x=4 (0100), y=2 (0010), f=1 (add).
  - Solution: 0100 + 0010 = 0110 (6).

* Wrap-up
** Takeaways
- Binary limits to \(2^k - 1\); addition carries overflow risks.
- Two's complement simplifies signed arithmetic.
- ALU integrates operations via control bits.
** Homework
- Convert -8 to 8-bit two's complement.
  - Solution: 8 = 00001000, invert = 11110111, +1 = 11111000.
- Add 5 + (-7) in 4-bit.
  - Solution: 5 = 0101, -7 = 1001, 0101 + 1001 = 1110 (-2).
- Read ALU implementation hints for next class.
